<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="聚沙成塔"><title>Redis数据结构之有序集合ZSet | Mr.Zhang's Blog</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.3"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.3"></script><script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.3"></script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis数据结构之有序集合ZSet</h1><a id="logo" href="/.">Mr.Zhang's Blog</a><p class="description">奋斗者~</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><search-result></search-result></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Redis数据结构之有序集合ZSet</h1><div class="post-meta"><a href="/2019/02/12/06-Redis数据结构之有序集合ZSet/#comments" class="comment-count"></a><p><span class="date">02月12日, 2019</span><span><a href="/categories/Redis/" class="category">Redis</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="Redis数据结构之有序集合ZSET"><a href="#Redis数据结构之有序集合ZSET" class="headerlink" title="Redis数据结构之有序集合ZSET"></a>Redis数据结构之有序集合ZSET</h2><blockquote>
<p>标签：<code>Redis</code>, <code>Zset</code>, <code>SkipList</code><br>转载：<a href="http://zhangtielei.com/posts/blog-redis-skiplist.html" target="_blank" rel="noopener">Redis内部数据结构详解(6)——skiplist</a>   </p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis的zset是一个有序的集合，其内部元素按照顺序排列且不重复(score可以重复)，这种特性让我们在实现排行榜功能时得心应手。    </p>
<p>说道有序的集合这很容易让我们联想到Java中的TreeSet数据结构, 使用TreeMap来实现，其底层是一个采用<br>红黑树存储的数据结构，但是红黑树的复杂旋转却让我们望而却步，Redis作者提供了另外一种跳跃表(SkipList)来实现，其处理简单而且性能与红黑树没有太大差别。   </p>
<p>接下类我们就一起学习一下Redis有序集合的常用API和实现原理。   </p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li><p><code>zadd &lt;key&gt; [NX|XX] [ch] [incr] &lt;score&gt; &lt;member&gt; [&lt;score&gt; &lt;member&gt;...]</code><br>功能：将所有指定成员添加到键为key的有序集合中，添加时可以指定多个分数成员(score/member)对.如果添加的成员已经是有序集合里面的成员，则会更新该成员的<br>分数(score)并更新到正确的排序配置。<br>参数选项：   </p>
<ul>
<li><em>XX</em>:仅仅更新存在的成员，不添加新成员   </li>
<li><em>NX</em>:不更新存在的成员，只添加新成员  </li>
<li><em>CH</em>:修改返回值为发生变化的成员总数，不指定时返回新添加成员的总数   </li>
<li><em>incr</em>:当zadd指定这个选项时，针对成员的分数进行递增操作   </li>
</ul>
</li>
<li><p><code>zincrby &lt;key&gt; &lt;score&gt; &lt;member&gt;</code><br>功能：将指定元素的score值增加<br>返回值：新的score值<br>时间复杂度：O(1)     </p>
</li>
<li><p><code>zrange &lt;key&gt; &lt;startIndex&gt; &lt;stopIndex&gt; [withscores]</code><br>功能：返回存储在有序集合中的指定范围的元素，返回的元素按照score正序排列，如果score相同将按照字典排序。<br>参数选项：  </p>
<ul>
<li><em>startIndex,stopIndex</em>:起始和结束的索引，0是第一个元素，1是第二个元素，也可以是是负数，-1代表最后一个元素(返回所有元素：zrange key 0 -1)  </li>
<li><em>withscores</em>:是否同时输出score值，输出结果将是value占一行，紧接着score占一行<br>时间复杂度：O(log(N)+M)   </li>
</ul>
</li>
<li><p><code>zrank &lt;key&gt; &lt;member&gt;</code><br>功能：返回有序集合中成员member的排名其中有序集成员按score值递增(从小到大)顺序排列。排名以0为底，也就是说，score值最小的成员排名为0。zrevrank为倒序<br>返回值：nil:不存在；其他：排名<br>时间复杂度：O(log(N))   </p>
</li>
<li><p><code>zscore &lt;key&gt; &lt;member&gt;</code><br>功能：返回集合中指定元素的score值<br>返回值：nil:不存在；其他：score值<br>时间复杂度：O(1)   </p>
</li>
<li><p><code>zcard &lt;key&gt;</code><br>功能：返回有序集合的元素个数<br>返回值：0：不存在；其他：元素个数<br>时间复杂度：O(1)   </p>
</li>
<li><p><code>zcount &lt;key&gt; &lt;minScore&gt; &lt;maxScore&gt;</code><br>功能：返回集合中score在minscore到maxScore之间的元素个数<br>返回值：元素个数<br>时间复杂度：O(log(N))   </p>
</li>
<li><p><code>zrangebylex &lt;key&gt; &lt;minMember&gt; &lt;maxMember&gt; [limit offset count]</code><br>功能：返回指定元素区间范围内的元素列表，正序输出。zrevrangelex为倒序<br>参数选项：   </p>
<ul>
<li><em>minMember, maxMember</em>：最小，最大元素，该参数必须包含<code>(</code>或者<code>[</code>, 其中<code>(</code>表示开区间，表示<code>[</code>闭区间，也可以直接使用<br>特殊值：<code>-</code>,<code>+</code>, <code>-</code>代表负无穷，<code>+</code>代表正无穷   </li>
<li><em>limit offset count</em>：该选项为可选值，表示结果分页，offset为返回分页下标，count为数量      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">    127.0.0.1:6379&gt; zadd rankList 1 user_1 4 user_4 8 user_8 5 user_5</span><br><span class="line">    (integer) 4</span><br><span class="line">    127.0.0.1:6379&gt; zadd rankList 6 user_6 10 user_10</span><br><span class="line">    (integer) 2</span><br><span class="line">    127.0.0.1:6379&gt; zrange rankList 0 -1</span><br><span class="line">    1) &quot;user_1&quot;</span><br><span class="line">    2) &quot;user_4&quot;</span><br><span class="line">    3) &quot;user_5&quot;</span><br><span class="line">    4) &quot;user_6&quot;</span><br><span class="line">    5) &quot;user_8&quot;</span><br><span class="line">    6) &quot;user_10&quot;</span><br><span class="line">    127.0.0.1:6379&gt; zrange rankList 0 -1</span><br><span class="line">    1) &quot;user_1&quot;</span><br><span class="line">    2) &quot;user_4&quot;</span><br><span class="line">    3) &quot;user_5&quot;</span><br><span class="line">    4) &quot;user_6&quot;</span><br><span class="line">    5) &quot;user_8&quot;</span><br><span class="line">    6) &quot;user_10&quot;</span><br><span class="line">    127.0.0.1:6379&gt; zrangebylex rankList - +</span><br><span class="line">    1) &quot;user_1&quot;</span><br><span class="line">    2) &quot;user_4&quot;</span><br><span class="line">    3) &quot;user_5&quot;</span><br><span class="line">    4) &quot;user_6&quot;</span><br><span class="line">    5) &quot;user_8&quot;</span><br><span class="line">    6) &quot;user_10&quot;</span><br><span class="line">    127.0.0.1:6379&gt; zrangebylex rankList - + limit 0 3</span><br><span class="line">    1) &quot;user_1&quot;</span><br><span class="line">    2) &quot;user_4&quot;</span><br><span class="line">    3) &quot;user_5&quot;</span><br><span class="line">    127.0.0.1:6379&gt; zrangebylex rankList - (user_5</span><br><span class="line">    1) &quot;user_1&quot;</span><br><span class="line">    2) &quot;user_4&quot;</span><br><span class="line">    127.0.0.1:6379&gt; zrangebylex rankList (user_1 (user_5</span><br><span class="line">    1) &quot;user_4&quot;</span><br><span class="line">    127.0.0.1:6379&gt; zrangebylex rankList [user_1 (user_5</span><br><span class="line">    1) &quot;user_1&quot;</span><br><span class="line">    2) &quot;user_4&quot;</span><br><span class="line">    ```   </span><br><span class="line">+ `zrangebyscore &lt;key&gt; &lt;minScore&gt; &lt;maxScore&gt; [withscores] [limit offset count]`   </span><br><span class="line">功能：与zrangebylex不同的是该命令是返回指定score区间内的元素列表   </span><br><span class="line"></span><br><span class="line">+ `zrem &lt;key&gt; &lt;member&gt; [&lt;member&gt;...]`  </span><br><span class="line">功能：移除指定元素  </span><br><span class="line">返回值：返回删除成功的元素个数，不包含不存在的元素    </span><br><span class="line"></span><br><span class="line">+ `zpopmax/zpopmin &lt;key&gt;`  </span><br><span class="line">功能：返回并移除最大score的元素  </span><br><span class="line"></span><br><span class="line">## 数据结构  </span><br><span class="line">zset是一个复合结构，一方面为了快速的获取指定value的score,一方面为了支持score排序，所以Redis做了这样的实现：  </span><br><span class="line">- 当数据较少时，sorted set是由一个ziplist来实现   </span><br><span class="line">- 当数据较多时(该数值可以进行配置)，采用了hash+skiplist(跳跃表)的复合结构来存储数据。      </span><br><span class="line">![](images/zset_001.png)    </span><br><span class="line"></span><br><span class="line">### 跳跃表的实现    </span><br><span class="line">跳跃表是一种通过链表和记录层级来规避红黑树，但比红黑树实现更简单的数据结构，Redis中只在两个地方用到了跳跃表，一个是实现有序集合，另一个是集群节点中</span><br><span class="line">用作内部数据结构。    </span><br><span class="line"></span><br><span class="line">skiplist, 它是一个list，它是在有序链表的基础上发展起来的。  </span><br><span class="line">我们先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）:  </span><br><span class="line">   </span><br><span class="line">![](images/skiplist_003.png)   </span><br><span class="line">在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。</span><br><span class="line">也就是说，时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。   </span><br><span class="line"></span><br><span class="line">假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图   </span><br><span class="line"></span><br><span class="line">![](images/skiplist_004.png)   </span><br><span class="line">这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。现在当我们想查找数据的时候，</span><br><span class="line">可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的</span><br><span class="line">指针所指向的方向进行的：    </span><br><span class="line"></span><br><span class="line">![](images/skiplist_005.png)   </span><br><span class="line">+ 23首先和7比较，再和19比较，比它们都大，继续向后比较。   </span><br><span class="line">+ 但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。   </span><br><span class="line">+ 23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间    </span><br><span class="line"></span><br><span class="line">在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。   </span><br><span class="line"></span><br><span class="line">利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：   </span><br><span class="line"></span><br><span class="line">![](images/skiplist_006.png)   </span><br><span class="line">   </span><br><span class="line">在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，接下来我们就知道只需要到19的后面去继续查找，</span><br><span class="line">从而一下子跳过了19前面的所有节点。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。   </span><br><span class="line"></span><br><span class="line">skiplist正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，</span><br><span class="line">这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，</span><br><span class="line">就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）</span><br><span class="line">重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。   </span><br><span class="line"></span><br><span class="line">skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，</span><br><span class="line">一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：   </span><br><span class="line"></span><br><span class="line">![](images/skiplist_007.png)   </span><br><span class="line"></span><br><span class="line">从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，</span><br><span class="line">插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，</span><br><span class="line">这让它在插入性能上明显优于平衡树的方案。   </span><br><span class="line"></span><br><span class="line">刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：  </span><br><span class="line"></span><br><span class="line">![](images/skiplist_008.png)  </span><br><span class="line"></span><br><span class="line">需要指出的是，执行插入操作时计算随机层数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，</span><br><span class="line">它的计算过程如下：  </span><br><span class="line">* 首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。     </span><br><span class="line">* 如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。     </span><br><span class="line">* 节点最大的层数不允许超过一个最大值，记为MaxLevel。     </span><br><span class="line"></span><br><span class="line">实现伪代码如下：  </span><br><span class="line">```text</span><br><span class="line">randomLevel() &#123;</span><br><span class="line">    level := 1</span><br><span class="line">    // random()返回一个[0...1)的随机数</span><br><span class="line">    while random() &lt; p and level &lt; MaxLevel do</span><br><span class="line">        level := level + 1</span><br><span class="line">    return level</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>在Redis的skiplist实现中，p=1/4, MaxLevel=32   </p>
<h3 id="Redis改进的跳跃表"><a href="#Redis改进的跳跃表" class="headerlink" title="Redis改进的跳跃表"></a>Redis改进的跳跃表</h3><h4 id="传统skiplist不能满足的情况"><a href="#传统skiplist不能满足的情况" class="headerlink" title="传统skiplist不能满足的情况"></a>传统skiplist不能满足的情况</h4><p>上面提到的SkipList并不能完全满足redis有序集合的所有操作，考虑下列这几种情况：   </p>
<ul>
<li>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。    </li>
<li>zscore由数据查询它对应的分数，这也不是skiplist所支持的。    </li>
<li>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。    </li>
<li>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key）。    </li>
</ul>
<h4 id="Redis针对skiplist的优化"><a href="#Redis针对skiplist的优化" class="headerlink" title="Redis针对skiplist的优化"></a>Redis针对skiplist的优化</h4><p>为了达到上面的几种处理效果，Redis做了如下处理：  </p>
<ul>
<li>当数据较少时，sorted set是由一个ziplist来实现的。   </li>
<li>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。  </li>
<li>zscore的查询，不是由skiplist来提供的，而是由那个dict来提供的。   </li>
<li>为了支持排名(rank)，Redis里对skiplist做了扩展，为每个节点增加了跨度的属性，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。而且，根据排名的查找，时间复杂度也为O(log n)。    </li>
<li>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。    </li>
<li>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。   </li>
</ul>
<blockquote>
<p>Redis中zset的数据结构定义  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//from sever.h ,version=4.0.10</span><br><span class="line"></span><br><span class="line">#define ZSKIPLIST_MAXLEVEL 32 /* Should be enough for 2^32 elements */</span><br><span class="line">#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */</span><br><span class="line"></span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    sds ele;</span><br><span class="line">    double score;</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    //层级节点数组</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        unsigned int span;// 跨度</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    struct zskiplistNode *header;</span><br><span class="line">    struct zskiplistNode *tail;</span><br><span class="line">    unsigned long length;  //元素数量</span><br><span class="line">    int level; //层级数</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line">typedef struct zset &#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<p>这段代码出自server.h，我们来简要分析一下：   </p>
<ul>
<li>开头定义了两个常量，ZSKIPLIST_MAXLEVEL和ZSKIPLIST_P，分别对应我们前面讲到的skiplist的两个参数：一个是MaxLevel，一个是p。   </li>
<li>zskiplistNode定义了skiplist的节点结构<ul>
<li>ele存放节点数据</li>
<li>score字段存储数据对应的排序值</li>
<li>backward字段是指向链表前一个节点的指针（前向指针）。节点只有1个前向指针，所以只有第1层链表是一个双向链表。</li>
<li>level[]存放指向各层链表后一个节点的指针（后向指针）。每层对应1个后向指针，用forward字段表示。另外，每个后向指针还对应了一个span值，<br>它表示当前的指针跨越了多少个节点。span用于计算元素排名(rank)，这正是Redis对于skiplist所做的一个扩展。</li>
</ul>
</li>
<li>zskiplist定义了真正的skiplist结构<ul>
<li>头指针header和尾指针tail</li>
<li>链表长度length，即链表包含的节点总数。注意，新创建的skiplist包含一个空的头指针，这个头指针不包含在length计数中</li>
<li>level表示skiplist的总层数，即所有节点层数的最大值</li>
</ul>
</li>
</ul>
<p>下图以前面插入的代数课成绩表为例，展示了Redis中一个skiplist的可能结构：<br><img src="/2019/02/12/06-Redis数据结构之有序集合ZSet/images/skiplist_009.png" alt>  </p>
<p>注意：图中前向指针上面括号中的数字，表示对应的span的值。即当前指针跨越了多少个节点，这个计数不包括指针的起点节点，但包括指针的终点节点。  </p>
<p>假设我们在这个skiplist中查找score=89.0的元素（即Bob的成绩数据），在查找路径中，我们会跨域图中标红的指针，这些指针上面的span值累加起来，<br>就得到了Bob的排名(2+2+1)-1=4（减1是因为rank值以0起始）。需要注意这里算的是从小到大的排名，而如果要算从大到小的排名，只需要用skiplist长度减去查找路径上的span累加值，即6-(2+2+1)=1。  </p>
<p>可见，在查找skiplist的过程中，通过累加span值的方式，我们就能很容易算出排名。相反，如果指定排名来查找数据（类似zrange和zrevrange那样），<br>也可以不断累加span并时刻保持累加值不超过指定的排名，通过这种方式就能得到一条O(log n)的查找路径。   </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Redis有序列表的实现"><a href="#Redis有序列表的实现" class="headerlink" title="Redis有序列表的实现"></a>Redis有序列表的实现</h3><ul>
<li>当数据较少时，sorted set是由一个ziplist来实现   </li>
<li>当数据较多时(该数值可以进行配置)，采用了hash+skiplist(跳跃表)的复合结构来存储数据。</li>
</ul>
<h3 id="skiplist与平衡树，哈希表的比较"><a href="#skiplist与平衡树，哈希表的比较" class="headerlink" title="skiplist与平衡树，哈希表的比较"></a>skiplist与平衡树，哈希表的比较</h3><ul>
<li>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。<br>所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。  </li>
<li>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。<br>如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。  </li>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。  </li>
<li>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，<br>具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。  </li>
<li>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，<br>性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。  </li>
<li>从算法实现难度上来比较，skiplist比平衡树要简单得多。  </li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: LeiLi.Zhang</p><p>原文链接: <a href="https://cnkeep.github.io/2019/02/12/06-Redis数据结构之有序集合ZSet/">https://cnkeep.github.io/2019/02/12/06-Redis数据结构之有序集合ZSet/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/02/12/09-Redis通讯协议/" class="pre">Redis通讯协议</a><a href="/2019/02/12/10-Redis事务/" class="next">Redis事务</a></div><div id="comments"><div id="container"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.3"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.3"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.3"></script><script>var gitalk = new Gitalk({
  clientID: '5b6acb94829bddd4a4b2',
  clientSecret: '718d07f690aa6efee404a48e1ffc762276be4d4a',
  repo: 'cnkeep.github.io',
  owner: 'cnkeep',
  admin: ['cnkeep'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis数据结构之有序集合ZSET"><span class="toc-number">1.</span> <span class="toc-text">Redis数据结构之有序集合ZSET</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">2.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用命令"><span class="toc-number">3.</span> <span class="toc-text">常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis改进的跳跃表"><span class="toc-number">3.1.</span> <span class="toc-text">Redis改进的跳跃表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#传统skiplist不能满足的情况"><span class="toc-number">3.1.1.</span> <span class="toc-text">传统skiplist不能满足的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis针对skiplist的优化"><span class="toc-number">3.1.2.</span> <span class="toc-text">Redis针对skiplist的优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis有序列表的实现"><span class="toc-number">4.1.</span> <span class="toc-text">Redis有序列表的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skiplist与平衡树，哈希表的比较"><span class="toc-number">4.2.</span> <span class="toc-text">skiplist与平衡树，哈希表的比较</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/02/13/02-Redis数据结构之string_01/">Redis数据结构之string_01</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/13/01-Redis介绍与使用场景/">Redis介绍与使用场景</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/13/11-Redis之pipeline批量处理/">Redis之pipeline批量处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/12/05-Redis数据结构之集合Set/">Redis数据结构之集合Set</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/12/09-Redis通讯协议/">Redis通讯协议</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/12/06-Redis数据结构之有序集合ZSet/">Redis数据结构之有序集合ZSet</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/12/10-Redis事务/">Redis事务</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/12/04-Redis数据结构之列表/">Redis数据结构之列表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/11/03-Redis数据结构之hash/">Redis数据结构之hash</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/11/07-Redis数据结构之HyperLogLog/">Redis数据结构之HyperLogLog</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Bugs/">Bugs</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Lock/">Lock</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Shell/">Shell</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ThreadPool/">ThreadPool</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/UML/">UML</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">17</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/UML/" style="font-size: 15px;">UML</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/Bugs/" style="font-size: 15px;">Bugs</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Lock/" style="font-size: 15px;">Lock</a> <a href="/tags/Netty/" style="font-size: 15px;">Netty</a> <a href="/tags/Network/" style="font-size: 15px;">Network</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/ThreadPool/" style="font-size: 15px;">ThreadPool</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://github.com/cnkeep" title="Github" target="_blank">Github</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">LeiLi.Zhang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>