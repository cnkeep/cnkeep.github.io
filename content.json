[{"title":"Hello World","date":"2019-03-28T03:45:41.057Z","path":"2019/03/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"tcpdump的使用","date":"2018-07-18T16:13:00.000Z","path":"2018/07/19/19-tcpdump的使用/","text":"tcpdump抓包工具的使用1. 介绍&nbsp;&nbsp;面对一些线上的网络问题排查时，经常需要抓取网络数据包进行分析，windows有大名鼎鼎的winshark, 而在linux就少有图形化的抓包工具，幸好有tcpdump工具的存在。 &nbsp;&nbsp; 它可以使用定义的规则抓取网卡上的数据包，便于我们分析数据。 2. 抓包原理2.1 原理介绍 抓包原理 Linux抓包是通过注册一种虚拟的底层网络协议来完成对网络报文(准确的说是网络设备)消息的处理权。当网卡接收到一个网络报文之后，它会遍历系统中所有已经注册的网络协议，当抓包模块把自己伪装成一个网络协议的时候，系统在收到报文的时候就会给这个伪协议一次机会，让它来对网卡收到的报文进行一次处理，此时该模块就会趁机对报文进行窥探，也就是把这个报文完完整整的复制一份，假装是自己接收到的报文，汇报给抓包模块。 注意事项 必须使用root身份执行 要抓取其他主机的数据包，需要开启混杂模式，即抓取任何经过它的数据包，不管这个数据包是不是发给它或者是它发出的。一般而言，Unix不会让普通用户设置混杂模式，因为这样可以看到别人的信息，比如telnet的用户名和密码，这样会引起一些安全上的问题，所以只有root用户可以开启混杂模式，开启混杂模式的命令是：ifconfig en0 promisc, en0是你要打开混杂模式的网卡。 2.2 命令介绍1. 命令格式12345678tcpdump [ -AdDefIKlLnNOpqRStuUvxX ] [ -B buffer_size ] [ -c count ] [ -C file_size ] [ -G rotate_seconds ] [ -F file ] [ -i interface ] [ -m module ] [ -M secret ] [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ] [ -W filecount ] [ -E spi@ipaddr algo:secret,... ] [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ] [ expression ] 2. 选项介绍-A：以ASCII编码打印每个报文（不包括链路层的头），这对分析网页来说很方便-a：将网络地址和广播地址转变成名字-c&lt;数据包数目&gt;：在收到指定的包的数目后，tcpdump就会停止-C：用于判断用 -w 选项将报文写入的文件的大小是否超过这个值，如果超过了就新建文件（文件名后缀是1、2、3依次增加）-d：将匹配信息包的代码以人们能够理解的汇编格式给出-dd：将匹配信息包的代码以c语言程序段的格式给出-ddd：将匹配信息包的代码以十进制的形式给出-D：列出当前主机的所有网卡编号和名称，可以用于选项 -i-e：在输出行打印出数据链路层的头部信息-f：将外部的Internet地址以数字的形式打印出来-F&lt;表达文件&gt;：从指定的文件中读取表达式,忽略其它的表达式-i&lt;网络界面&gt;：监听主机的该网卡上的数据流，如果没有指定，就会使用最小网卡编号的网卡（在选项-D可知道，但是不包括环路接口），linux 2.2 内核及之后的版本支持 any 网卡，用于指代任意网卡-l：如果没有使用 -w 选项，就可以将报文打印到 标准输出终端（此时这是默认）-n：显示ip，而不是主机名-N：不列出域名-O：不将数据包编码最佳化-p：不让网络界面进入混杂模式-q：快速输出，仅列出少数的传输协议信息-r&lt;数据包文件&gt;：从指定的文件中读取包(这些包一般通过-w选项产生)-s&lt;数据包大小&gt;：指定抓包显示一行的宽度，-s0表示可按包长显示完整的包，经常和-A一起用，默认截取长度为60个字节，但一般ethernet MTU都是1500字节。所以，要抓取大于60字节的包时，使用默认参数就会导致包数据丢失-S：用绝对而非相对数值列出TCP关联数-t：在输出的每一行不打印时间戳-tt：在输出的每一行显示未经格式化的时间戳记-T&lt;数据包类型&gt;：将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议）-v：输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息-vv：输出详细的报文信息-x:/-xx/-X/-XX：以十六进制显示包内容，几个选项只有细微的差别，详见man手册-w:&lt;数据包文件&gt;：直接将包写入文件中，并不分析和打印出来expression：用于筛选的逻辑表达式； 3. 常用选项 抓取指定数目的包(-c选项) 默认情况下tcpdump将一直抓包，直到按下”ctrl+c”中止，使用-c选项可以指定抓包的数量。 将抓到包写入文件中(-w选项) 使用-w选项，可将抓包记录到一个指定文件中，以供后续分析 读取tcpdump保存文件(-r选项) 对于保存的抓包文件，可以使用-r选项进行读取 抓包时不进行域名解析(-n选项) 默认情况下，tcpdump抓包结果中将进行域名解析，显示的是域名地址而非ip地址，使用-n选项，可指定显示ip地址。 显示完整的包(-s0) 4. 表达式介绍 表达式是一个正则表达式，tcpdump利用它作为过滤报文的条件，如果一个报文满足表达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包将会被截获。在表达式中一般如下几种类型的关键字: 类型关键字主要包括host，net，port，缺省是host 传输方向关键字主要包括src（源地址）, dst(目标地址) ,dst or src, dst and src, 缺省是src or dst 协议关键字主要包括fddi,ip ,arp,rarp,tcp,udp等类型 3. 示例1. 监视指定网络接口的数据包 12# tcpdump -i eth1 如果不指定网卡，默认tcpdump只会监视第一个网络接口上所有流过的数据包，一般是eth0，下面的例子都没有指定网络接口。 2. 监视指定主机的数据包12345678910111213141516171819202122232425截获所有210.27.48.1 的主机收到的和发出的所有的数据包 # tcpdump host 210.27.48.1``` ### 3. TCP连接 这里通过telnet工具连接redis测试tcp连接的报文抓取 ```text [root@localhost redis-5.0.3]# tcpdump -i eth1 -v -s 0 port 6379 tcpdump: listening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes[1] 21:56:41.602246 IP (tos 0x0, ttl 64, id 54118, offset 0, flags [DF], proto TCP (6), length 52)[2] 172.16.22.235.54586 &gt; localhost.localdomain.6379: Flags [S], cksum 0xbe8b (correct), seq 1436544059, win 64240, options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0[3] 21:56:41.602294 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 52)[4] localhost.localdomain.6379 &gt; 172.16.22.235.54586: Flags [S.], cksum 0x85b9 (incorrect -&gt; 0xdaf5), seq 3525089865, ack 1436544060, win 29200, options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0[5] 21:56:41.602446 IP (tos 0x0, ttl 64, id 54119, offset 0, flags [DF], proto TCP (6), length 40)[6] 172.16.22.235.54586 &gt; localhost.localdomain.6379: Flags [.], cksum 0x85d3 (correct), ack 1, win 2053, length 0[7] 21:56:48.665457 IP (tos 0x0, ttl 64, id 54123, offset 0, flags [DF], proto TCP (6), length 40)[8] 172.16.22.235.54586 &gt; localhost.localdomain.6379: Flags [F.], cksum 0x85d2 (correct), seq 1, ack 1, win 2053, length 0[9] 21:56:48.665797 IP (tos 0x0, ttl 64, id 58678, offset 0, flags [DF], proto TCP (6), length 40)[10] localhost.localdomain.6379 &gt; 172.16.22.235.54586: Flags [F.], cksum 0x85ad (incorrect -&gt; 0x8cf1), seq 1, ack 2, win 229, length 0[11] 21:56:48.666220 IP (tos 0x0, ttl 64, id 54124, offset 0, flags [DF], proto TCP (6), length 40)[12] 172.16.22.235.54586 &gt; localhost.localdomain.6379: Flags [.], cksum 0x85d1 (correct), ack 2, win 2053, length 0 ^C 6 packets captured 16 packets received by filter 0 packets dropped by kernel 分析12345678[1]~[6] 3次握手 [7]~[12] 4次挥手拿[1]来看，proto： 指明协议是TCPlength：报文长度srcHost:srcPort &gt; destHost:destPort :指明源地址端口和目标地址端口Flags[*]: 指明包类型，S代表SYN; .代表ACK; F代表FIN","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"EOF的使用","date":"2018-07-18T13:59:00.000Z","path":"2018/07/18/18-EOF的使用/","text":"Linux下EOF的使用1. 介绍如果我们需要往一个文件里自动输入N行内容。如果是少数的几行内容，还可以用echo追加方式，但如果是很多行，那么单纯用echo追加的方式就显得复杂了，这时候就可以使用EOF结合cat命令进行内容的追加了。 2. 用法123&lt;&lt;EOF ...EOF 通过cat配合重定向能够生成文件并追加操作,在它之前先熟悉几个特殊符号:&lt; :输入重定向&gt; :输出重定向&gt;&gt; :输出重定向,进行追加,不会覆盖之前内容&lt;&lt; :标准输入来自命令行的一对分隔号的中间内容. 3.示例1234567# cat &lt;&lt;EOF&gt;test.sh&gt; ssss&gt; lllll&gt; EOF# more test.sh sssslllll","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"which_where_find","date":"2018-07-17T12:46:00.000Z","path":"2018/07/17/17-which_where_find/","text":"which, whereis, find的区别","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"挂载","date":"2018-07-16T09:42:00.000Z","path":"2018/07/16/16-挂载/","text":"https://blog.csdn.net/csh86277516/article/details/78844830https://blog.csdn.net/qq_39521554/article/details/79501714","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"proc目录探查系统信息","date":"2018-07-16T07:40:00.000Z","path":"2018/07/16/16-proc目录探查系统信息/","text":"/proc目录探查系统信息 标签：/proc 介绍/proc 文件系统下的多种文件提供的系统信息不是针对某个特定进程的, 而是能够在整个系统范围的上下文中使用。可以使用的文件随系统配置的变化而变化。命令procinfo 能够显示基于其中某些文件的多种系统信息。包含：内存，硬盘等 使用 CPU1$ cat /proc/cpuinfo Memory12$ cat /proc/meminfo$ free -m 硬盘12$ fdisk -l$ df -h 其他 123456netstat -lntp # 查看所有监听端口 netstat -antp # 查看所有已经建立的连接 w # 查看活动用户 id # 查看指定用户信息 last # 查看用户登录日志 rpm -qa # 查看所有安装的软件包","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"yum工具配置","date":"2018-07-15T06:27:00.000Z","path":"2018/07/15/15-yum工具配置/","text":"yum工具配置介绍yum是一款软件包管理器，能够从指定的服务器自动下载RPM包并且安装，还可以自动处理依赖性关系，yum提供了查找、安装、删除某一个，一组甚至全部软件包的命令，而且命令简洁而又好记。 常用命令介绍 1.查找与显示123456# 查找软件yum search &lt;package&gt;#显示安装包信息yum info &lt;package&gt;#显示已经安装和可以安装的程序包yum list 2.安装1yum install &lt;package&gt; 3.更新与升级12345#更新yum update [&lt;package&gt;]#升级程序yum upgrade &lt;package&gt; 4.移除程序1234#移除程序包yum remove &lt;package&gt;##查看依赖yum deplist &lt;package&gt; 5.缓存12345#缓存清除yum clean #生成缓存yum makecache 配置及目录介绍 1.配置文件/etc/yum.conf 1234567891011121314151617181920212223242526[main]cachedir=/var/cache/yum/$basearch/$releaseverkeepcache=0debuglevel=2logfile=/var/log/yum.logexactarch=1obsoletes=1gpgcheck=1plugins=1installonly_limit=5bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yumdistroverpkg=centos-release# This is the default, if you make this bigger yum won&apos;t see if the metadata# is newer on the remote and so you&apos;ll &quot;gain&quot; the bandwidth of not having to# download the new metadata and &quot;pay&quot; for it by yum not having correct# information.# It is esp. important, to have correct metadata, for distributions like# Fedora which don&apos;t keep old packages around. If you don&apos;t like this checking# interupting your command line usage, it&apos;s much better to have something# manually check the metadata once an hour (yum-updatesd will do this).# metadata_expire=90m# PUT YOUR REPOS HERE OR IN separate files named file.repo# in /etc/yum.repos.d 简单介绍一下： cachedir: yum缓存目录，yum在此存储下载的rpm包和数据库 logfile: 日志文件 2.镜像仓库配置目录/etc/yum.repos.d/123$ ls /etc/yum.repos.d/Centos-7.repo CentOS-CR.repo CentOS-fasttrack.repo CentOS-Sources.repo docker-ce.repo_bakCentOS-Base.repo_bak CentOS-Debuginfo.repo CentOS-Media.repo CentOS-Vault.repo 该目录下面的配置文件指明了镜像的源地址配置，我们可以在此配置新的镜像源地址 3.插件等其他的配置文件目录/etc/yum/yum/12$ ls /etc/yum/yum/fssnap.d pluginconf.d protected.d vars version-groups.conf 这里重点介绍pluginconf.d/目录是相关插件的配置目录，后面介绍的fastestmirror插件配置文件就在这里 拓展添加源添加阿里的镜像源 123#配置域名解析# vi /etc/resolve.conf nameserver 8.8.8.8 方式一：12345678910#备份原有配置$ mv /etc/yum.repos.d/Centos-7.repo /etc/yum.repos.d/Centos-7.repo.bak# 下载阿里镜像配置$ sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/repo/Centos-7.repo#清理缓存$ sudo yum clean#构建缓存$ sudo yum makecache 方式二:123456789#备份原有配置$ mv /etc/yum.repos.d/Centos-7.repo /etc/yum.repos.d/Centos-7.repo.bak# 下载阿里镜像配置$ wget http://mirrors.aliyun.com/repo/Centos-7.repo$ mv Centos-7.repo /etc/yum.repos.d/Centos-7.repo#清理缓存$ sudo yum clean all#构建缓存$ sudo yum makecache 方式三：12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 查看缓存存储路径$ yum-config-manager|grep base_persistdirpersistdir = /var/lib/yum/repos/x86_64/7base_persistdir = /var/lib/yum/repos/x86_64/7base_persistdir = /var/lib/yum/repos/x86_64/7$ cd /var/lib/yum/repos/x86_64/7$ vi /etc/yum.conf [main] cachedir=/var/cache/yum/$basearch/$releasever keepcache=0 debuglevel=2 logfile=/var/log/yum.log exactarch=1 obsoletes=1 gpgcheck=1 plugins=1 #将plugins的值修改为0 installonly_limit=5$ sudo yum install yum-plugin-fastestmirror$ vi /etc/yum/pluginconf.d/fastestmirror.conf [main] enabled=1 #配置为1 verbose=0 always_print_best_host = true socket_timeout=3 # Relative paths are relative to the cachedir (and so works for users as well # as root). hostfilepath=timedhosts.txt maxhostfileage=10 maxthreads=15 #exclude=.gov, facebook #include_only=.nl,.de,.uk,.ie $ vi /var/cache/yum/x86_64/7/timedhosts.txt #加入下列内容 mirrors.aliyuncs.com 99999999999 mirrors.cloud.aliyuncs.com 99999999999 mirrors.aliyun.com 2.03075098991#清理缓存$ sudo yum clean all#构建缓存$ sudo yum makecache","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"开机启动项","date":"2018-07-13T02:09:00.000Z","path":"2018/07/13/14-开机启动项/","text":"开机启动项 标签：Redis, systemctl, chkconfig参考：Linux实现开机自动运行普通用户脚本参考：systemctl管理Redis启动、停止、开机启动 前言最近在玩Redis时，因为是放在虚拟机里跑的，但是虚拟机需要经常关机和开机，导致每次都要手动重启redis, 但是我受够了想让它开机自启，于是就有了今天的内容。 设置开机自启方案方案一:使用/etc/rc.d/rc.local自启动脚本文件实现开机自动运行普通用户脚本。 把需要开机启动的脚本程序直接写入/etc/rc.d/rc.local文件中，这样子开机时就会自动执行这些脚本程序，运行对应的服务程序。需要在root环境下编辑。 方案二:使用chkconfig和/etc/init.d 我们都了解/etc/init.d目录下的所有文件都是脚本文件，这个目录下的脚本文件，在设置到开机自启动后，会在开机时自动执行。 1.root账号编写自启动脚本12345678$ vi /etc/init.d/redis#!/bin/bash# redis auto start scripts#chkconfig: 235 80 30 --235指定的启动级别，在哪写启动级别下启动；--80 启动的优先级；--30 关闭的优先级su /usr/local/app/redis-5.0.3/src/redis-server /usr/local/app/redis-5.0.3/redis.conf --daemonize no 等级0表示：表示关机等级1表示：单用户模式等级2表示：无网络连接的多用户命令行模式等级3表示：有网络连接的多用户命令行模式等级4表示：不可用等级5表示：带图形界面的多用户模式等级6表示：重新启动 2.添加执行权限1$ chmod +x /etc/init.d/redis 3.加入启动项配置1234#假如启动项$ chkconfig --add redis #设置开机启动$ chkconfig redis on 4.查看启动项1$ chkconfig --list 方案三(推荐):使用systemctl和/lib/systemd/system/ 1.编写脚本1234567891011121314$ vi /lib/systemd/system/redis.service#写入以下内容[Unit]Description=Redis_5.0.1After=network.target[Service]#redis安装绝对路径ExecStart=/usr/local/app/redis-5.0.3/src/redis-server /usr/local/app/redis-5.0.3/redis.conf --daemonize noExecStop=/usr/local/app/redis-5.0.3/src//redis-cli -h 127.0.0.1 -p 6379 shutdown[Install]WantedBy=multi-user.target [Unit] 表示这是基础信息 Description 是描述 After 是在那个服务后面启动，一般是网络服务启动后启动 [Service] 表示这里是服务信息 ExecStart 是启动服务的命令 ExecStop 是停止服务的指令 [Install] 表示这是是安装相关信息 WantedBy 是以哪种方式启动：multi-user.target表明当系统以多用户方式（默认的运行级别）启动时，这个服务需要被自动运行。 详细请移步至：CoreOS实践指南（八）：Unit文件详解 2.设置开机启动123456789$ ln -s /lib/systemd/system/redis.service /etc/systemd/system/multi-user.target.wants/redis.service#刷新配置$ systemctl daemon-reload#开启开机自启功能$ systemctl enable redis$ systemctl [start|stop|restart|status] redis 3.查看启动项1$ systemctl list-unit-files *","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"wc命令","date":"2018-07-11T23:02:00.000Z","path":"2018/07/12/13-wc命令/","text":"1234567891011wc -l #统计行数 -c, --bytes print the byte counts -m, --chars print the character counts -l, --lines print the newline counts --files0-from=文件 从指定文件读取以NUL 终止的名称，如果该文件被 指定为&quot;-&quot;则从标准输入读文件名 -L, --max-line-length 显示最长行的长度 -w, --words 显示单词计数 --help 显示此帮助信息并退出 --version 显示版本信息并退出","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"echo转义&&换行","date":"2018-07-10T20:57:00.000Z","path":"2018/07/11/12-echo转义&&换行/","text":"echo中的转义与换行经常使用echo命令，但是不知道怎么转义可不换行，今天用到了，做一下笔记。 1.原样输出(使用单引号)12345678910111213echo &apos;$name \\n end&apos;#output:# $name \\n end``` &gt; 2.显示转义字符(-e) ```textecho -e &apos;$name \\n end&apos;#output:# $name # end 3.不换行(\\c)12345echo -e &quot;$name \\n end \\c&quot; &amp;&amp; echo &quot;===&quot; #output:# $name # end ===","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"head&tail命令","date":"2018-07-10T16:44:00.000Z","path":"2018/07/11/11-head&tail命令/","text":"head &amp; tail命令命令功能&nbsp;&nbsp;倒序或者顺序查看文件内容 命令格式12$tail [filename]$head [filename] 常用参数示例 倒序查看100行1$tail -n 100 [filename] 倒序查看文件动态刷新，用于日志观察1$tail -f [filename] 查看文件前10行1$head -n 10 [filename]","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"vi命令","date":"2018-07-08T13:32:00.000Z","path":"2018/07/08/10-vi命令/","text":"vi命令命令功能&nbsp;&nbsp;vi命令是linux提供的强大的文本编辑工具，接下来我们就常用的功能做一下记录(非全部)。 vi查找 当你用vi打开一个文件后，因为文件太长，如何才能找到你所要查找的关键字呢？ /或者?,在命令模式下敲斜杆(/)这时在状态栏（也就是屏幕左下脚）就出现了 “/”然后输入你要查找的关键字敲回车就可以了。如果你要继续查找此关键字，敲字符n就可以继续查找了。值得注意的是“/”是向下查找，而“?”是向上查找，而在键盘定义上“?”刚好是“/”的上档符。 vi替换： vi/vim 中可以使用 ：s 命令来替换字符串以前只会使用一种格式来全文替换，这里只说部分 123456：s/vivian/sky/ 替换当前行第一个 vivian 为 sky：s/vivian/sky/g 替换当前行所有 vivian 为 sky：n,$s/vivian/sky/ 替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky：n,$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky n 为数字，若 n 为 .，表示从当前行开始到最后一行：%s/vivian/sky/（等同于：g/vivian/s//sky/）替换每一行的第一个 vivian 为 sky：%s/vivian/sky/g（等同于：g/vivian/s//sky/g）替换每一行中所有 vivian 为 sky 鼠标移动操作12345命令模式下``H,J,K,L``字符可以实现鼠标跳转，这几个键都是紧挨着的，操作多方便哦！ H:向前移动J:向下移动K:向上移动L:向后移动 行数操作12345#显示行号:set nu跳转到第10行:10 翻页12Ctrl+B: 上一页Ctrl+F: 下一页 复制，粘贴，撤销，删除1234yy: 复制当前行p: 粘贴u: 撤销更改dd: 删除","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"03_通过Dockerfile构建自己的镜像文件","date":"2018-07-07T15:24:00.000Z","path":"2018/07/07/01-03_通过Dockerfile构建自己的镜像文件/","text":"通过Dockerfile构建自己的镜像文件目录Dockerfile是什么Dockerfile指令介绍示例-构建jdk镜像Dockerfile是什么&emsp;&emsp;Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。其产出为一个新的可以用于创建容器的镜像。 Dockerfile指令 FROM &emsp;&emsp;FROM指令用于指定当前镜像所使用的的基础镜像，一般写在文件开头，如果想自定义构建docker镜像，那么引用的基础镜像一般是：centos, debian, ubuntu。 指令语法：1234567FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt;FROM &lt;image&gt;:&lt;digest&gt;示例：FROM centos:v1 MAINTAINER &emsp;&emsp;MAINTAINER用于描述当前Dockerfile的文件信息指令语法：12345MAINTAINER &lt;name&gt;示例：MAINTAINER LeiLi.Zhang &lt;zhangleili924@gmail.com&gt; 3.RUN &emsp;&emsp;运行指定命令，此命令只有在执行docker build构建镜像时才会执行，Dokcerfile中的命令每执行一条即产生一个新的镜像，当前命令总是在最新的镜像上执行，所以为了避免缓存之类的影响，应尽量将多条命令合并为一条执行，每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用\\来换行。 指令格式：1234567RUN &lt;command&gt;示例：RUN yum update \\&amp;&amp; yum install openjdk-8-jdk -y \\&amp;&amp; yum clean all 4.CMD &emsp;&emsp;设置容器启动时要执行的命令，只有在执行run 或者 start时才会运行，假如有多条命令只会执行最后一条，执行会覆盖。指令格式：1CMD [&quot;java -version&quot;] 5.EXPOSE 设置容器的暴露端口，注意并不是指暴露到物理机上的端口号！！！指令语法：1EXPOSE port 6.ENV 此指令为设置环境变量指令语法：1234ENV &lt;key&gt; &lt;value&gt;示例：ENV JAVA_HOME /usr/local/jdk 7.ADD 该指令的功能是把宿主机文件复制到镜像中，目录会自动创建。指令格式：12345ADD &lt;src&gt; &lt;dest&gt; src可以是网络资源示例：ADD /usr/local/app/jdk /usr/lib/jdk 绝对路径方式：将宿主机/usr/local/app/jdk目录拷贝到镜像/usr/lib/jdk目录ADD jdk /usr/lib/jdk 相对路径方式：将相对当前Dockerfile文件路径下的jdk目录拷贝至惊醒/usr/lib/jdk目录 8.COPY 此命令与ADD命令功能相似，不同的是，src只能是本地文件，且文件路径是Dockerfile的相对路径指令格式：1234COPY &lt;src&gt; &lt;dest&gt;示例：COPY jdk /usr/lib/jdk 将相对当前Dockerfile文件路径下的jdk目录拷贝至惊醒/usr/lib/jdk目录 9.VLOUME &emsp;&emsp;设置你的卷，在启动容器的时候Docker会在/var/lib/docker/的下一级目录下创建一个卷，以保存你在容器中产生的数据。若没有申明则不会创建。(可以把此指令看成shell中的mkdir）此指令不是独立数据卷，数据会随着容器的停止而消失，如果想数据持久化，请参考docker 简单命令 在run启动容器是加-V 参数！ 指令格式：1VLOUME [&quot;&quot;] 10.WORKDIR 指定容器的工作目录，可以在构建镜像的时候使用，也可以在启动容器的时候使用，构建使用是通过WORKDIR将当前目录切换到指顶目录中，可以理解为shell的cd，启动容器的时候使用的意思为 docker run 启动容器时，默认进入到目录是WORKDIR 指定的。 指令语法：1WORKDIR /usr 11.ENTRYPOINT RNTRYPONT指令与CMD指令的作用类似，都是在容器启动时执行相关的指令，不同的是， CMD中的参数会被启动时指定的动态参数替换掉，而ENTRYPOINT不会被替换掉。 CMD和ENTRYPOINT同时存在时，CMD中的指令会被一般结合这两者进行配置，ENTRYPOINT设置指令，CMD设置参数, 例如： 123#DockerfileENTRYPOINT [&quot;/bin/ping&quot;,&quot;-c&quot;,&quot;3&quot;]CMD [&quot;localhost&quot;] /bin/ping -c 3 localhost 示例-构建jdk镜像这里示例制作一个基于nginx镜像的jdk镜像 1.下载jdk 这里使用的是jdk1.8.0_172，通过工具上传到服务器/usr/local/dock_file目录（请自行事先建立该目录）12$ls /usr/local/docker_fileDockerfile jdk1.8.0_172 2.创建Dockerfile文件1234567891011121314151617181920212223$ cd /usr/local/docker_file$ touch Dockerfile#vi Dockerfile追加以下内容：#这里的基础镜像为nginxFROM nginxMAINTAINER LeiLi.Zhang#切换镜像目录WORKDIR /usrRUN mkdir jdk#将宿主机当前目录下的jdk1.8.0_172拷贝至镜像的/user/jdk目录下ADD jdk1.8.0_172 /usr/jdk$ 设置环境变量ENV JAVA_HOME=/usr/jdkENV JRE_HOME=$JAVA_HOME/jreENV CLASSPATH=.:$CLASSPATH:$JAVA_HOME/bin/dt.jar:$JAVA_HOME/lib/tools.jarENV PATH=$PATH:$JAVA_HOME/binCMD [&quot;java&quot;, &quot;-version&quot;] 3.构建镜像文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$ docker build -f Dockerfile -t nginx_jdk8:1.0 ./Sending build context to Docker daemon 388.7MBStep 1/10 : FROM nginx ---&gt; 06144b287844Step 2/10 : MAINTAINER LeiLi.Zhang ---&gt; Running in 9fd7dfb2fdd4Removing intermediate container 9fd7dfb2fdd4 ---&gt; 8a1b63746989Step 3/10 : WORKDIR /usr ---&gt; Running in 600d738f937fRemoving intermediate container 600d738f937f ---&gt; 337b6327788cStep 4/10 : RUN mkdir jdk ---&gt; Running in e6533a32955eRemoving intermediate container e6533a32955e ---&gt; d18d4dd904d9Step 5/10 : ADD jdk1.8.0_172 /usr/jdk_8 ---&gt; 5a537bbcd84cStep 6/10 : ENV JAVA_HOME=/usr/jdk_8 ---&gt; Running in 3db8397affdbRemoving intermediate container 3db8397affdb ---&gt; 596cf637b2a7Step 7/10 : ENV JRE_HOME=$JAVA_HOME/jre ---&gt; Running in c16754fc69e0Removing intermediate container c16754fc69e0 ---&gt; b4b8531e6846Step 8/10 : ENV CLASSPATH=.:$CLASSPATH:$JAVA_HOME/bin/dt.jar:$JAVA_HOME/lib/tools.jar ---&gt; Running in d0be05ab96cfRemoving intermediate container d0be05ab96cf ---&gt; 606d80d75a70Step 9/10 : ENV PATH=$PATH:$JAVA_HOME/bin ---&gt; Running in eedc61c6889bRemoving intermediate container eedc61c6889b ---&gt; f5f3ca76f4dbStep 10/10 : CMD [&quot;java&quot; ,&quot;-version&quot;] ---&gt; Running in 5101d2bc1ebcRemoving intermediate container 5101d2bc1ebc ---&gt; 0118d7df925aSuccessfully built 0118d7df925aSuccessfully tagged nginx_jdk8:1.0``` &gt; 4.查看镜像是否成功 ```text$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEnginx_jdk8 1.0 cb6b8f24a584 24 seconds ago 496MBredis latest c188f257942c 7 weeks ago 94.9MBtime69/docker_study centos_base 7121cccf893c 3 months ago 982MBhello-world latest 4ab4c602aa5e 4 months ago 1.84kBtomcat latest 7671687227db 4 months ago 463MBnginx latest 06144b287844 4 months ago 109MBcentos latest 5182e96772bf 5 months ago 200MB 4.使用创建的镜像 123456$ docker run -it --name jdk8 nginx_jdk8:1.0 /bin/bash$ java -versionjava version &quot;1.8.0_172&quot;Java(TM) SE Runtime Environment (build 1.8.0_172-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.172-b11, mixed mode) 5.导出镜像123$ docker save -o jdk_1.8_nginx.tar nginx_jdk8:1.0当面目录生成xxx.tar 6.导入镜像1$ docker load -i jdk_1.8_nginx.tar","tags":[{"name":"Docker","slug":"Docker","permalink":"https://cnkeep.github.io/tags/Docker/"}]},{"title":"user_group_chmod命令","date":"2018-07-07T10:27:00.000Z","path":"2018/07/07/09-user_group_chmod命令/","text":"user相关 &amp; group相关 &amp; chmod命令 本文中的命令参数选项并非全部选项，仅包含常用选项 用户系统&emsp;&emsp;linux是一个多用户多任务的系统，它有用户，用户组的概念，一个用户必须属于一个组。 user相关 与用户相关的配置文件1234567891011121314151617181920212223242526272829303132333435/etc/passwd 用户的配置文件/etc/shadow 用户的影子口令``` &gt; 与用户相关的命令 ```text1. useradd 功能：新建用户 用法：useradd [选项] 登录 useradd -D useradd -D [选项] 选项： -b, --base-dir BASE_DIR 新账户的主目录的基目录 -d, --home-dir HOME_DIR 新账户的主目录 -e, --expiredate EXPIRE_DATE 新账户的过期日期 -f, --inactive INACTIVE 新账户的密码不活动期 -g, --gid GROUP 新账户主组的名称或 ID -G, --groups GROUPS 新账户的附加组列表 -m, --create-home 创建用户的主目录 -M, --no-create-home 不创建用户的主目录 -p, --password PASSWORD 加密后的新账户密码 -r, --system 创建一个系统账户 示例： $ useradd -g zll_group -G root zll #新建用户zll, 用户主组zll_group, 附组root $ passwd zll #设置密码 $ id zll #查看用户zll的组 uid=1122(zll_group) gid=1125(zll_group) groups=1125(zll_group),0(root) $ useradd -s /sbin/nologin test #创建一个不能登录的用户2. usermod 功能：修改用户3. userdel 功能：删除用户 group相关 group相关配置文件 1/etc/group group相关命令 123456789101112131415161. groupadd 功能：新建用户组 用法：groupadd [选项] 用户组 选项： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 示例： $ groupadd zll_group2. groupmod 功能：修改用户组3. groupdel 功能：删除用户组 文件权限&emsp;&emsp;linux的文件系统拥有严格访问权限，文件的可读可写，所属人，所属组都有严格的限制，我们也可以人为控制修改，这时候就要用到chmod命令了。我们先看看文件都有什么权限：123456789101112131415161718192021222324252627282930311：代表文件类型，为目录是为d2: 代表文件的宿主权限，由三位表示，4：可读，2：可写，1：可执行 3：代表文件的所属组权限4：代表其他用户的权限5：代表文件的所属用户6：代表文件的所属组``` &gt; chmod命令可以修改文件的相关权限 ```text语法： chmod [-cfvR] [--help] [--version] mode file...参数说明： [ugoa...][[+-=][rwxX]...][,...] 其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作 -f : 若该文件权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) --help : 显示辅助说明 --version : 显示版本 示例： $ chmod +x start.sh #增加执行权限 chown可以修改文件的饿所属者 12345678910111213141516171819语法 chown [-cfhvR] [--help] [--version] user[:group] file...参数 : user : 新的文件拥有者的使用者 ID group : 新的文件拥有者的使用者组(group) -c : 显示更改的部分的信息 -f : 忽略错误信息 -h :修复符号链接 -v : 显示详细的处理信息 -R : 处理指定目录以及其子目录下的所有文件 --help : 显示辅助说明 --version : 显示版本实例 #将文件 file1.txt 的拥有者设为 users 群体的使用者 runoob : $ chown runoob:users file1.txt #将目前目录下的所有文件与子目录的拥有者皆设为 users 群体的使用者 lamport : $ chown -R lamport:users *","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"sed命令","date":"2018-07-07T09:23:00.000Z","path":"2018/07/07/08-sed命令/","text":"sed命令[注：文中的命令参数列表至列出了常用的几个，并不是全部] sed命令 功能 &emsp;&emsp;sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用, 可以完成文件内容的批量替换，删除等。 使用方式及参数列表 1234567891011121314151617181920212223242526sed [options] &apos;command&apos; file(s)参数列表： g 表示行内全面替换。 p 表示打印行。 i 修改源文件 w 表示把行写入一个文件。 x 表示互换模板块中的文本和缓冲区中的文本。 y 表示把一个字符翻译为另外的字符（但是不用于正则表达式） \\1 子串匹配标记 &amp; 已匹配字符串标记 匹配模式： ^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。 $ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。 . 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。 * 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 [] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。 \\(..\\) 匹配子串，保存匹配的字符，如s/\\(love\\)able/\\1rs，loveable被替换成lovers。 &amp; 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。 \\&lt; 匹配单词的开始，如:/\\&lt;love/匹配包含以love开头的单词的行。 \\&gt; 匹配单词的结束，如/love\\&gt;/匹配包含以love结尾的单词的行。 x\\&#123;m\\&#125; 重复字符x，m次，如：/0\\&#123;5\\&#125;/匹配包含5个0的行。 x\\&#123;m,\\&#125; 重复字符x，至少m次，如：/0\\&#123;5,\\&#125;/匹配至少有5个0的行。 x\\&#123;m,n\\&#125; 重复字符x，至少m次，不多于n次，如：/0\\&#123;5,10\\&#125;/匹配5~10个0的行。 示例 12345678910111.选项-i,匹配file文件中每一行的第一个book替换为books： $ sed -i &apos;s/book/books/g&apos; file2.-n选项和p命令一起使用表示只打印那些发生替换的行： $ sed -n &apos;s/test/TEST/p&apos; file 3.使用后缀 /g 标记会替换每一行中的所有匹配： $ sed &apos;s/book/books/g&apos; file #不会修改源文件 4.替换文件中所有的6379为6380并生成新文件 $ sed &apos;s/6379/6380/g&apos; redis.conf &gt; redis-6380.conf","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"时间同步","date":"2018-07-06T08:22:00.000Z","path":"2018/07/06/07-时间同步/","text":"Centos7时间不同步总是早8小时转载-CentOS 7系统时间与实际时间差8个小时 问题场景&emsp;&emsp;自己安装在虚拟机中的Centos时间总是早8个小时，每次都需要我手动改，太麻烦，今天终于决定彻底结局它。 结局方案123456789101112131415161718192021222324252627282930313233$ timedatectl #查看时间 Local time: 三 2018-10-24 23:30:48 CST Universal time: 三 2018-10-24 15:30:48 UTC RTC time: 三 2018-10-24 15:30:48 Time zone: Asia/Shanghai (CST, +0800) NTP enabled: n/aNTP synchronized: no RTC in local TZ: no DST active: n/a $ ls /usr/share/zoneinfo/ #查看时区列表Africa Australia Cuba Etc GMT-0 Indian Kwajalein Navajo posix ROK UTCAmerica Brazil EET Europe GMT+0 Iran Libya NZ posixrules Singapore WETAntarctica Canada Egypt GB Greenwich iso3166.tab MET NZ-CHAT PRC Turkey W-SUArctic CET Eire GB-Eire Hongkong Israel Mexico Pacific PST8PDT UCT zone.tabAsia Chile EST GMT HST Jamaica MST Poland right Universal ZuluAtlantic CST6CDT EST5EDT GMT0 Iceland Japan MST7MDT Portugal ROC US$ rm /etc/localtime #删除原有的时区rm：是否删除符号链接 &quot;/etc/localtime&quot;？y$ sudo ln -s /usr/share/zoneinfo/Universal /etc/localtime #设置新的时区$ timedatectl Local time: 三 2018-10-24 15:46:55 UTC Universal time: 三 2018-10-24 15:46:55 UTC RTC time: 三 2018-10-24 15:46:54 Time zone: Universal (UTC, +0000) NTP enabled: n/aNTP synchronized: no RTC in local TZ: no DST active: n/a[root@localhost default]# date2018年 10月 24日 星期三 15:46:58 UTC","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"centos7防火墙","date":"2018-07-06T05:08:00.000Z","path":"2018/07/06/06-centos7防火墙/","text":"centos防火墙1234567891011121314151617181920212223242526272829303132333435363738391、firewalld的基本使用启动： systemctl start firewalld查看状态： systemctl status firewalld 停止： systemctl disable firewalld禁用： systemctl stop firewalld 2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl --failed3.配置firewalld-cmd查看版本： firewall-cmd --version查看帮助： firewall-cmd --help显示状态： firewall-cmd --state查看所有打开的端口： firewall-cmd --zone=public --list-ports更新防火墙规则： firewall-cmd --reload查看区域信息: firewall-cmd --get-active-zones查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0拒绝所有包：firewall-cmd --panic-on取消拒绝状态： firewall-cmd --panic-off查看是否拒绝： firewall-cmd --query-panic 那怎么开启一个端口呢添加firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效）重新载入firewall-cmd --reload查看firewall-cmd --zone= public --query-port=80/tcp删除firewall-cmd --zone= public --remove-port=80/tcp --permanent","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"启动脚本中1,2&是什么","date":"2018-07-06T00:57:00.000Z","path":"2018/07/06/05-启动脚本中1,2&是什么/","text":"启动脚本末尾的2&gt;&amp;1 &amp;的含义脚本中2&gt;&amp;1 &amp;的含义 &emsp;&emsp;我们总是在启动脚本中会发现这样的 “2&gt;&amp;1 &amp;”的奇怪部分，那这部分到底是什么含义呢？ linux标准输入输出流的标示&emsp;&emsp;我们知道设备都有输入输出流，那么linux中是如何去标示它们的呢？1230: 标准stdin输入流1：标准stdout输出流2：标准stderr错误流 举例分析 来看这样一个例子 command >2>&1 & ```12345678910我们对命令进行拆分： ![&amp;](images/how_about_&amp;.png) ```text1：我们执行的命令2：命令执行的打印信息流重定向的设备，**/dev/null**表示一个空设备，即重定向到它后不显示任何信息3：代表标准stderr流4：代表标准stdout输出流，这里的**&amp;**表示不把1当做文件看待，不添加&amp;则会把1当做文件看待5：表示以后台job的形式执行命令6：把stderr流重定向到stdout流","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"重定向符号区别","date":"2018-07-05T22:56:00.000Z","path":"2018/07/06/04-重定向符号区别/","text":"&gt; 和 &gt;&gt; 区别 功能 &emsp;&emsp;都表示重定向到新的设备。 区别 两者的区别主要发生在重定向的设备已经存在时： &gt;会覆盖源文件 &gt;&gt;不会覆盖源文件，而是追加到源文件末尾","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"lrzsz上传下载工具","date":"2018-07-05T20:44:00.000Z","path":"2018/07/06/03-lrzsz上传下载工具/","text":"lrzsz上传下载工具应用场景&emsp;&emsp;我们使用linux时，经常需要与本机完成文件的传输，我们可以使用xftp, 但是还有更简单的命令。 lrzsz的使用 123$ yum install lrzsz$ rz #弹框选择文件上传到linux当前目录 $ sz [file] #从Linux下载文件","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"02_Docker命令","date":"2018-07-05T15:21:00.000Z","path":"2018/07/05/01-02_Docker命令/","text":"命令列表 删除Docker12$ sudo yum remove docker-ce$ sudo rm -rf /var/lib/docker 搜索可用镜像1$ docker search [name] 拉取镜像123$ docker pull [name]:[version]其中version可以省略 查看镜像列表1$ docker images 运行容器123456789101112$ docket start [container] 运行一个已经存在的容器$ docker run -p 8080:80 --name test -d [image] 利用镜像image新建一个容器并启动$ docker run -d -i -t [image] /bin/bash 后台运行防止直接退出docker run 等价于 docker create + docker startrun: 利用镜像image创建一个容器并启动-p: 端口映射，容器内80端口映射到外部的8080端口--name: 容器命名-d: 后台运行-v: 文件映射 查看容器列表1$ docker ps -a 进入容器1$ docker exec -it [container] /bin/bash 停止容器1$ docker stop [container] 重启docker守护进程12$ systemctl daemon-reload$ systemctl restart docker 查看容器运行日志1$ docker logs [container] 查看容器信息1$ docker inspect [container] 移除容器1234$ docker rm [container]移除所有容器$ docker rm $(docker ps -a -q) 通过Dockerfile构建镜像1$ docker build -it [image] [path] 通过容器构建镜像1234567$ docker commit -a [author] [container] [repository[:tag]]示例：$ docker commit -a &quot;LeiLi.Zhang&quot; -m &quot;jdk8,nginx1.15,tomcat8.5.23&quot; centos_7 my:centos_base通过容器centos_7构建一个镜像-a 作者-m 提交信息 镜像的导出导入12345导出$ docker save -o xxxx.tar [image]导入$ docker load -i xxx.tar 容器的导入导出12$ docker export [container] &gt; xxx.tar$ cat xxx.tar | docker import - [res]:[tag]： DockerHub1234567拉取镜像$ docker login$ docker pull [name:tag]上传镜像$ docker tag [image:tag] [username/repository:tag] 将本地镜像重命名为标准的名称$ docker push [username/repository:tag] 查看容器/镜像的分层1$ docker history [image] 网络操作123456$ docker network [option]|[contain]# ls 查看网卡# inspect 查看网络信息# create 创建新的网卡# connect 连接到新的网卡","tags":[{"name":"Docker","slug":"Docker","permalink":"https://cnkeep.github.io/tags/Docker/"}]},{"title":"grep命令","date":"2018-07-03T16:30:00.000Z","path":"2018/07/04/02-grep命令/","text":"grep命令[注：文中的命令参数列表至列出了常用的几个，并不是全部] grep命令 功能 &emsp;&emsp;Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来. 使用方式及参数列表 1234567891011121314151617181920212223242526272829grep [option] pattern file参数列表： -a --text #不要忽略二进制的数据。 -A&lt;显示行数&gt; --after-context=&lt;显示行数&gt; #除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -b --byte-offset #在显示符合样式的那一行之前，标示出该行第一个字符的编号。 -B&lt;显示行数&gt; --before-context=&lt;显示行数&gt; #除了显示符合样式的那一行之外，并显示该行之前的内容。 -c --count #计算符合样式的列数。 -C&lt;显示行数&gt; --context=&lt;显示行数&gt;或-&lt;显示行数&gt; #除了显示符合样式的那一行之外，并显示该行之前后的内容。 -d &lt;动作&gt; --directories=&lt;动作&gt; #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。 -e&lt;范本样式&gt; --regexp=&lt;范本样式&gt; #指定字符串做为查找文件内容的样式。 -E --extended-regexp #将样式为延伸的普通表示法来使用。 -f&lt;规则文件&gt; --file=&lt;规则文件&gt; #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -F --fixed-regexp #将样式视为固定字符串的列表。 -G --basic-regexp #将样式视为普通的表示法来使用。 -h --no-filename #在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H --with-filename #在显示符合样式的那一行之前，表示该行所属的文件名称。 -i --ignore-case #忽略字符大小写的差别。 -l --file-with-matches #列出文件内容符合指定的样式的文件名称。 -L --files-without-match #列出文件内容不符合指定的样式的文件名称。 -n --line-number #在显示符合样式的那一行之前，标示出该行的列数编号。 -q --quiet或--silent #不显示任何信息。 -r --recursive #此参数的效果和指定“-d recurse”参数相同。 -s --no-messages #不显示错误信息。 -v --revert-match #显示不包含匹配文本的所有行。 -V --version #显示版本信息。 -w --word-regexp #只显示全字符合的列。 -x --line-regexp #只显示全列符合的列。 -y #此参数的效果和指定“-i”参数相同 示例 12345678910111213141516171. 进程查找 $ ps -ef|grep redis 2. 查找指定进程个数 $ ps -ef|grep -c svn 3. 从文件中读取关键词进行搜索 $ cat test.txt | grep -f test2.txt 4. 找出已u开头的行内容 $ cat test.txt |grep ^u 5. 去除注释和空格显示 $ cat redis.conf |grep -v &quot;#&quot;|grep -v &quot;^$&quot; &gt; redis-template.conf 6. 显示匹配行后面几行 $ grep -A &apos;options&apos; my.cnf","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"01_Docker介绍与安装","date":"2018-07-03T15:10:00.000Z","path":"2018/07/03/01-01_Docker介绍与安装/","text":"Docker目录什么是DockerDocker用来干什么Docker相关的点安装Docker什么是Docker&emsp;&emsp;不同的应用程序可能会有不同的应用环境，如果把他们依赖的软件都安装在一个服务器上就要调试很久，而且很麻烦，还会造成一些冲突。这个时候你就要隔离，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小。 除此之外，它还可以像jvm屏蔽操作系统的底层细节，让我们的应用在不同系统部署变得更加方便。 总结就是：Docker是一个便携的应用容器, 我们的程序可以运行在容器之中。 Docker用来干什么 更快的运行服务，更高效的利用机器资源，更多的服务发布 屏蔽不同系统之间的差异，可以做到处处可部署运行，避免多次搭建环境(再也不会出现开发环境好好地，线上跑不起来了) 容器化带来了安全隔离，不在因为一个服务挂，导致所有服务挂 Docker相关的点Kubernetes, jenkins 安装Docker 本文采用Centos7作为服务器安装Docker, 详情参考官方：https://docs.docker.com/install/linux/docker-ce/centos/. 卸载docker旧版本12345678910$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine 安装工具类123$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 配置docker仓库1234567891011$ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 会报以下错误： Loaded plugins: fastestmirror adding repo from: https://download.docker.com/linux/centos/docker-ce.repo grabbing file https://download.docker.com/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo Could not fetch/save url https://download.docker.com/linux/centos/docker-ce.repo to file /etc/yum.repos.d/docker-ce.repo : [Errno 14] curl$ 35 - &quot;TCP connection reset by peer 这是由于国内访问不到docker官方镜像的缘故可以通过aliyun的源来完成：1234567$ sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 出现以下内容则表示docker仓库配置成功： Loaded plugins: fastestmirror adding repo from: http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo grabbing file http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo repo saved to /etc/yum.repos.d/docker-ce.repo 参考：Docker CE 镜像源站 安装社区版docker 1234567891011$ sudo yum install docker-ce 内容如下： Installed: docker-ce.x86_64 0:18.03.0.ce-1.el7.centos Dependency Installed: audit-libs-python.x86_64 0:2.7.6-3.el7 checkpolicy.x86_64 0:2.5-4.el7 container-selinux.noarch 2:2.42-1.gitad8f0f7.el7 libcgroup.x86_64 0 libtool-ltdl.x86_64 0:2.4.2-22.el7_3 pigz.x86_64 0:2.3.3-1.el7.centos policycoreutils-python.x86_64 0:2.5-17.1.el7 python-IPy.noarch Complete! 验证是否安装成功123456789101112启动docker：$ sudo systemctl start docker验证docker:$ sudo docker run hello-world则会出现以下异常：Unable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-world9bb5a5d4561a: Pulling fs layerdocker: error pulling image configuration: Get https://dseasb33srnrn.cloudfront.net/registry-v2/docker/registry/v2/blobs/sha256/e3/e38bc07ac18eSee &apos;docker run --help&apos;. 镜像加速 上面提到的错误也是网络问题：国内无法访问dockerhub, 我们配置一下加速地址，登录https://www.daocloud.io 注册账号,使用Docker 加速器或者注册阿里云开发者获取加速地址 1$ curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://b481a1dd.m.daocloud.io 该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中（该文件不存在可手动建立）。 12345678910111213141516171819202122232425262728测试是否成功$ docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-worldd1725b59e92d: Pull complete Digest: sha256:523e382ab1801f2a616239b1052bb7ee5a7cce6a06cfed27ccb93680eacad6efStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 目录结构默认情况下Docker的存放位置为：/var/lib/docker可以通过docker info命令查看 创建容器时通过-v 命令可以指定容器与宿主机之间的目录映射关系 启动Docker服务 pull命令从远程仓库拉取指定镜像(Image)，或者通过Dockerfile构建(build)新的镜像 使用run或者create+start命令，利用镜像生成容器并启动，一个镜像可以生成多个容器 镜像可以通过save,load命令导入导出，完成镜像的共享转移","tags":[{"name":"Docker","slug":"Docker","permalink":"https://cnkeep.github.io/tags/Docker/"}]},{"title":"maven私服搭建","date":"2018-07-02T16:22:00.000Z","path":"2018/07/03/01-maven私服搭建/","text":"使用Docker搭建maven私服 标签：maven, nexus3 参考： Nexus安装、使用说明、问题总结 从Maven私服获取依赖 Maven私有仓库: 发布release版本报错： Maven私服:Docker安装nexus3 前言作为一个Java程序员不可避免的要使用到maven仓库，但是我们经常遇见这样的情形： 网络受限，无法下载远程仓库的jar 公司内部的jar，无法获取，只能手动安装 远程现在速度太慢 针对以上的问题，我们就需要自己搭建一个Maven私服仓库。 介绍私服是架设在局域网的一种特殊的远程仓库，目的是代理远程仓库及部署第三方构件。有了私服之后，当 Maven 需要下载构件时，直接请求私服，私服上存在则下载到本地仓库；否则，私服请求外部的远程仓库，将构件下载到私服，再提供给本地仓库下载。 安装配置Nexus为了方便操作，我们直接采用docker安装 安装12345678910111213141516$ mkdir /home/nexus3# 搜索镜像$ docker search nexus3#下载镜像$ docker pull sonatype/nexus3# 启动$ docker run -id \\ --name=nexus3 \\ --privileged=true \\ --restart=always \\ -p 8081:8081 \\ -v /home/nexus3:/var/nexus-data \\ sonatype/nexus3 等待几分钟后，访问http://{ip}:8081/ 默认用户名admin，密码admin123 配置 1.配置镜像地址12345678910111213141516171819202122232425262728293031323334353637383940 &lt;mirrors&gt; &lt;!-- 私服镜像 --&gt;&lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://172.16.22.136:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 阿里云镜像 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;url&gt;http://172.16.22.136:8081/repository/maven-public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt; &lt;/activeProfiles&gt; 2.配置用户名密码123456789101112&lt;servers&gt; &lt;server&gt; &lt;id&gt;maven-releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;maven-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt; 3.配置项目pom.xml12345678910111213&lt;!--私服仓库--&gt;&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;maven-releases&lt;/id&gt; &lt;name&gt;Nexus Release Repository&lt;/name&gt; &lt;url&gt;http://172.16.22.136:8081/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;maven-snapshots&lt;/id&gt; &lt;name&gt;Nexus Snapshot Repository&lt;/name&gt; &lt;url&gt;http://172.16.22.136:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt;&lt;/distributionManagement&gt; 4.发布1$ mvn deploy 登录到nexus上就可以看到刚才打包的jar, 如果遇到：Return code is: 400, ReasonPhrase: Repository does not allow upd ating assets: maven-releases. 这是因为重复发布导致的，需要设置：","tags":[{"name":"Docker","slug":"Docker","permalink":"https://cnkeep.github.io/tags/Docker/"}]},{"title":"cd命令","date":"2018-07-02T12:26:00.000Z","path":"2018/07/02/01-cd命令/","text":"cd命令1.命令功能 切换当前目录至指定目录下 2.命令格式1cd [dirpath] 3.示例 显示当前目录12$pwd/home/zll 切换目录到当前用户home目录下12345678$cd ~或者$cd ``` &gt; 切换目录到上一次目录下 ```text$cd - 切换到父目录下1$cd ..","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"hook钩子","date":"2018-03-16T19:44:00.000Z","path":"2018/03/17/02-hook钩子/","text":"Git中的hook钩子程序原文: Git中文官网-8.3 自定义 Git - Git 钩子 Git钩子&nbsp;&nbsp;Git能在特定的重要动作发生时触发自定义的脚本，俗称钩子(hooks)，类似于事件回调机制。Git中存在两组这样的钩子： 客户端钩子：由诸如提交和合并这样的操作所调用。 服务端钩子：作用域诸如接收被推送的提交这样的联网操作。 安装钩子&nbsp;&nbsp;当我们clone或者init一个仓库后，会在目录下生成.git目录，该目录即我们的git管理目录，其内部存在一个hooks的子目录，该目录下默认防止了一些以.sample结尾的示例脚本，当我们要激活一个钩子时，只需要去掉后缀，改写脚本即可。脚本支持多种语言,可以在首行指定#!/usr/bin/env XXX 这些脚本只对当前项目发挥作用，而且每次都需要从其他仓库复制一份进来，我们可以修改全局的配置（以windows为例），在git安装目录下的mingw64\\share\\git-core\\templates\\hooks目录下存在着全局脚本，我们可以修改这里的脚本，这样每次init后当前仓库中的脚本就会从全局中复制过来。 客户端钩子 pre-commit: 执行git commit命令时触发，常用于检查代码风格 prepare-commit-msg: commit message编辑器呼起前default commit message创建后触发，常用于生成默认的标准化的提交说明 commit-msg: 开发者编写完并确认commit message后触发，常用于校验提交说明是否标准 post-commit: 整个git commit完成后触发，常用于邮件通知、提醒 applypatch-msg: 执行git am命令时触发，常用于检查命令提取出来的提交信息是否符合特定格式 pre-applypatch: git am提取出补丁并应用于当前分支后，准备提交前触发，常用于执行测试用例或检查缓冲区代码 post-applypatch: git am提交后触发，常用于通知、或补丁邮件回复（此钩子不能停止git am过程） pre-rebase: 执行git rebase命令时触发 post-rewrite: 执行会替换commit的命令时触发，比如git rebase或git commit –amend post-checkout: 执行git checkout命令成功后触发，可用于生成特定文档，处理大二进制文件等 post-merge: 成功完成一次 merge行为后触发 pre-push: 执行git push命令时触发，可用于执行测试用例 pre-auto-gc: 执行垃圾回收前触发 服务端钩子 pre-receive: 当服务端收到一个push操作请求时触发，可用于检测push的内容 update: 与pre-receive相似，但当一次push想更新多个分支时，pre-receive只执行一次，而此钩子会为每一分支都执行一次 post-receive: 当整个push操作完成时触发，常用于服务侧同步、通知 这些钩子有如下的关系(颜色深的为常用钩子)： 示例：提交后自动maven打包 如果目录下存在pom.xml则打包(需已安装maven)，不考虑打包失败的情况, 修改post-commit文件`text #!/bin/sh# An example hook script to prepare a packed repository for use overdumb transports.# To enable this hook, rename this file to “post-update”.if [ -f “pom.xml” ];then mvn clean -Dmaven.test.skip=true package installelse echo “[!Error]not found pom.xml” echo “==========================”fi`","tags":[{"name":"Git","slug":"Git","permalink":"https://cnkeep.github.io/tags/Git/"}]},{"title":"gitlab搭建","date":"2018-03-15T16:38:00.000Z","path":"2018/03/16/01-gitlab搭建/","text":"Docker方式安装gitlab 标签： Gitlab，Docker 开发中如果我们不希望代码托管在第三方平台，我们就可以自己搭建一套git服务端，这里采用流行的Gitlab和Docker搭建 1.安装gitlab1.1 环境介绍 Linux Centos, Linux localhost.localdomain 3.10.0-514.10.2.el7.x86_64 #1 SMP Fri Mar 3 00:04:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux docker Docker version 18.09.0, build 4d60db4 内存&amp;硬盘 内存&gt;4G, 硬盘&gt;20G 1.2 下载安装 1.镜像下载&amp;安装 拉取镜像1$ docker pull gitlab/gitlab-ce 建立容器映射文件夹 1234# 提前建立映射文件夹$ mkdir /home/gitlab/config$ mkdir /home/gitlab/data$ mkdir /home/gitlab/logs 启动容器 123456789101112131415$ docker run \\ --d \\ --privileged=true \\ --p 8443:443 \\ --p 8090:8090 \\ #web访问端口 --p 4422:4422 \\ #ssh访问端口 --name gitlab \\ --restart unless-stopped \\ -v /home/gitlab/config:/etc/gitlab \\ -v /home/gitlab/logs:/var/log/gitlab \\ -v /home/gitlab/data:/var/opt/gitlab \\ v /etc/localtime:/etc/localtime \\ gitlab/gitlab-ce:latest \\# 启动较为缓慢，需要等大约2分钟 2.配置端口123456789101112131415$ vi /home/gitlab/config/gitlab.rb## 修改http方式的端口密码 external_url &apos;http://172.16.22.135:8090&apos;## 修改ssh端口gitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 4422# 修改ssh端口$ docker exec -it gitlab /bin/bash$ vi /assets/sshd_config#修改ssh端口Port 4422#重启配置$gitlab-ctl reconfigure 参见：Gitlab SSH端口不生效 配置邮件服务 邮件服务配置 阿里云邮箱配置12345678910$ vi /home/gitlab/config/gitlab.rbgitlab_rails[&apos;smtp_enable&apos;] = truegitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.mxhichina.com&quot;gitlab_rails[&apos;smtp_port&apos;] = 465gitlab_rails[&apos;smtp_user_name&apos;] = &quot;&lt;your user_name&gt;&quot;gitlab_rails[&apos;smtp_password&apos;] = &quot;&lt;your passwd&gt;&quot;gitlab_rails[&apos;smtp_domain&apos;] = &quot;&lt;your domain&gt;&quot;gitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;gitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = truegitlab_rails[&apos;smtp_tls&apos;] = true 邮件服务测试12345678910111213141516171819202122232425262728293031$ docker exec -it gitlab /bin/bash#重启配置$gitlab-ctl reconfigureroot@8176a338c3ef:/# gitlab-rails console------------------------------------------------------------------------------------- GitLab: 11.6.5 (237bddc) GitLab Shell: 8.4.3 postgresql: 9.6.11-------------------------------------------------------------------------------------Loading production environment (Rails 5.0.7)irb(main):001:0&gt; Notify.test_email('1348555156@qq.com','subject','content').deliver_nowNotify#test_email: processed outbound mail in 173.5msSent mail to 1348555156@qq.com (2970.6ms)Date: Tue, 22 Jan 2019 14:40:57 +0000From: Gitlab &lt;zhangleili@cnkeep.cn&gt;Reply-To: Gitlab &lt;noreply@172.16.22.135&gt;To: 1348555156@qq.comMessage-ID: &lt;5c472b798ae1b_ae3fba61cca5f08927@8176a338c3ef.mail&gt;Subject: subjectMime-Version: 1.0Content-Type: text/html; charset=UTF-8Content-Transfer-Encoding: 7bitAuto-Submitted: auto-generatedX-Auto-Response-Suppress: All&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"http://www.w3.org/TR/REC-html40/loose.dtd\"&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;content&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;=&gt; #&lt;Mail::Message:70069490324460, Multipart: false, Headers: &lt;Date: Tue, 22 Jan 2019 14:40:57 +0000&gt;, &lt;From: Gitlab &lt;zhangleili@cnkeep.cn&gt;&gt;, &lt;Reply-To: Gitlab &lt;noreply@172.16.22.135&gt;&gt;, &lt;To: 1348555156@qq.com&gt;, &lt;Message-ID: &lt;5c472b798ae1b_ae3fba61cca5f08927@8176a338c3ef.mail&gt;&gt;, &lt;Subject: subject&gt;, &lt;Mime-Version: 1.0&gt;, &lt;Content-Type: text/html; charset=UTF-8&gt;, &lt;Content-Transfer-Encoding: 7bit&gt;, &lt;Auto-Submitted: auto-generated&gt;, &lt;X-Auto-Response-Suppress: All&gt;&gt;irb(main):002:0&gt;","tags":[{"name":"Git","slug":"Git","permalink":"https://cnkeep.github.io/tags/Git/"}]},{"title":"git的原理","date":"2018-03-15T15:27:00.000Z","path":"2018/03/15/01-git的原理/","text":"git的内部原理Git的内部原理&emsp;&emsp;Git本质上是一个内容寻址文件系统，从内部来看它是一个key-value数据库，可以插入任意内容，并返回一个键值，可以通过该键值在任何时候再取出该内容。接下来我们初始化一个本地仓库看看细节原理。 原理解析目录结构首先我们初始化一个本地仓库后，发现生成一个.git文件夹，git的存储和操作都是在操作这些文件(还记得它是一个文件系统吗)我们来看看目录结构以及每个目录的作用：12345678910111213141516├─HEAD 保存当前指向的分支├─config 保存当前项目的git配置选项├─index 保存暂存区信息├─COMMIT_EDITMSG 保存提交记录├─hooks├─logs 提交记录│ ├─HEAD│ └─refs├─info│ └─exclude├─objects git的核心数据存储│ ├─info│ └─pack└─refs 存储指向数据 (分支) 的提交对象的指针 ├─heads └─tags 上面这些目录中最重要的就是index和HEAD, objects和refs, logs这几个部分 原理分析接下来我们从add和commit命令来看git的运行原理。 为什么是内容寻址文件系统 &emsp;&emsp;我们前面提到Git是一个内容寻址文件系统，那么为什么这么说呢？其实Git是采用Key-Value数据存储原理，为每个数据通过SHA-1计算出一个键值key，采用key的前2位分目录创建目录，key的剩余部分为文件名，将原来的内容压缩作为文本内容存储。这样只要我们知道一个key就能轻易找到文件并还原出原文件内容，这就是.git/objects目录的内容结构。我们可以使用git cat-file -p key查看文件内容。 git的三个区域 介绍之前我们先要了解git相关的三个目录区域： 工作区(working directory): 对应我们真是操作的文件目录 暂存区(staged或者叫index): 对应.git/index 本地仓库(repository): 对应.git/objects目录它们之间的关系如图所示： git中的对象 Git中的对象有Commit, Tree, Blob, Tag四种对象，前三种最重要，我们先介绍着几个对象的作用，后面再讲Git是如何通过这些对象完成版本控制的。 Commit: 记录提交记录的信息，包含author, message, parent(前一个commit对象指针)，Tree对象指针 Tree: 用于记录目录结构的一组指针，包含文件类型，文件指针(Tree或者Blob),文件名 Blob: 存储压缩后的内容它们之间的关系如图所示： 正向操作 接下来就最常见的正常操作add，commit命令来看Git的工作原理12345678910111213141516171819202122232425262728293031323334353637383940414243$ git init #初始化一个本地仓库 $ vi readme.txt #创建一个文件$ This is readme. $ find .git/objects/ -type f #查看对象库，为空$ git ls-files --stage #查看暂存区信息，即.git/index内容$ git add readme.txt #文件放入暂存区，这一步会将readme.txt放入对象库并生成key存储在.git/index中$ find .git/objects/ -type f #查看对象库，生成新的文件.git/objects/52/cb6cdb81a64344370c918a301eb153035f915a$ git cat-file -t 52cb6cdb81a64344370c918a301eb153035f915a #查看对象类型blob #blob对象，存储文件内容$ git cat-file -p 52cb6cdb81a64344370c918a301eb153035f915a #查看文件内容This is readme. #文件内容与我们写入的一致$ git ls-file --stage #查看缓存区100644 52cb6cdb81a64344370c918a301eb153035f915a 0 readme.txt #记录着blob对象$ git commit -m &quot;add readme.txt&quot; #提交暂存区到本地仓库中$ find .git/objects/ -type f #查看对象库.git/objects/52/cb6cdb81a64344370c918a301eb153035f915a #Blob对象.git/objects/9b/6f349ad11c58d0e930dd12134a3e536bf5b057 #Tree对象.git/objects/d6/1479babc75f198416b5fd3caece3495b976391 #Commit对象$ vi readme.txtThis is readme.add line.$ git status #查看工作区和暂存区的文件状态，可以知道那些已经被暂存，那些没有On branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)$ git add readme.txt $ git commit -m &quot;change readme.txt&quot;$ find .git/objects/ -type f #查看对象库.git/objects/3a/3cf98cad23cb084fa1753bee60e9f97d08e317 #Tree对象.git/objects/52/cb6cdb81a64344370c918a301eb153035f915a #Blob对象，readme.txt:v1.git/objects/62/c1331ab1c19f93dd776e894404aebc6de14b85 #Blob对象，readme.txt:v2.git/objects/9b/6f349ad11c58d0e930dd12134a3e536bf5b057 #Tree对象，.git/objects/a6/08354310f5aec4436a99feab92c96c35fa895c #Commit对象，commit:2.git/objects/d6/1479babc75f198416b5fd3caece3495b976391 #Commit对象, commit:1 通过上面的操作我们可以分析出原理： git add: 通过将文件生成新的Blob对象，并提交到暂存区，写.git/index文件 git commit:通过暂存区生成Tree对象，Commit对象，提交到版本库，写.git/logs目录 git会为每一个的更改都保存一个副本经过一系列操作，最终形成如下结构: 逆向操作 所谓逆向操作，就是指撤销之前的操作，来分析一下Git的处理原理, 即checkout和reset命令。我们以撤销readme.txt的修改为例。12345678910111213141516171819202122232425262728293031323334353637383940414243444546$ git log #查看当前的commit结点commit a608354310f5aec4436a99feab92c96c35fa895c (HEAD -&gt; master)Author: TIME69 &lt;zhangleili924@gmail.com&gt;Date: Wed Sep 19 01:48:36 2018 +0800 change readme.txtcommit d61479babc75f198416b5fd3caece3495b976391Author: TIME69 &lt;zhangleili924@gmail.com&gt;Date: Wed Sep 19 01:38:42 2018 +0800 add readme.txt$ git rest HEAD^ #将版本库回退到上一个版本，此操作只是将HEAD指针指向前一个Commit对象而已,并将暂存区会退到上一个版本Unstaged changes after reset: #可以看到撤销了暂存区的更改M readme.txt$ git log #查看当前Head, 看到上次更改撤销了commit d61479babc75f198416b5fd3caece3495b976391 (HEAD -&gt; master)Author: TIME69 &lt;zhangleili924@gmail.com&gt;Date: Wed Sep 19 01:38:42 2018 +0800 add readme.txt $ git ls-files --stage #查看暂存区100644 52cb6cdb81a64344370c918a301eb153035f915a 0 readme.txt$ git cat-file -p 52cb6cdb81a64344370c918a301eb153035f915a #暂存区内容已经回退，但是工作区呢？This is readme.$ git diff --stage #查看暂存区和版本库的差异，发现没有差异，是相同的$ cat readme.txt #发现工作区没有回退This is readme.add line.$ git status #On branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)$ git checkout readme.txt #将工作区回退到上一个版本$ cat readme.txt #发现工作区内容变回来了This is readme. 看似很完美，但是这时候有人会说了那我不想撤销了咋办，我找不到记录了吗？怎么会，Git帮你存着呢。所有的提交记录Git都记录下来了(保存在.git/logs目录下的相应文件里)，不用怕丢，我们可以通过git reflog命令查看立即记录。1234$ git reflogd61479b (master) HEAD@&#123;6&#125;: reset: moving to HEAD^a608354 HEAD@&#123;7&#125;: commit: change readme.txtd61479b (master) HEAD@&#123;8&#125;: commit (initial): add readme.txt 我们知道Git操作的都是指针而已，那我们只要把HEAD指针指向下一个Commit结点不就完了，完美！1234$ git reset a608354 #暂存区Unstaged changes after reset:M readme.txt$ git checkout readme.txt #工作区 最终我们解决的问题，只要搞懂了底层机理是不是一下简单了许多，我们把工作区，暂存区，版本库之间的转换总结为下面这一张图： 内存压缩 我们上面说到git会对每一次的提交都保存一个副本Blob对象，那我们想一下那不是有很多冗余，很占存储空间，那能不能像svn那样存储变化的部分呢？其实Git已经考虑到了这一点，所以其内部有一个碎片处理的gc操作，类似于svn，但却有所区别。12345678910111213141516171819202122232425$ git gc #手动执行碎片处理Counting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (5/5), done.Total 5 (delta 1), reused 0 (delta 0)$ find .git/objects/ -type f #查看对象库，发现pack目录多了文件，之前的object文件不见了.git/objects/info/packs.git/objects/pack/pack-57cbdc16b7fd157d77451245ef44ba68ea567e14.idx.git/objects/pack/pack-57cbdc16b7fd157d77451245ef44ba68ea567e14.pack$ git verify-pack -v .git/objects/pack/pack-57cbdc16b7fd157d77451245ef44ba68ea567e14.idx #查看pack文件a2d7df5381d7c3086ba998c6e7528725082e7e92 commit 218 157 12a608354310f5aec4436a99feab92c96c35fa895c commit 73 79 169 1 a2d7df5381d7c3086ba998c6e7528725082e7e92d61479babc75f198416b5fd3caece3495b976391 commit 167 125 24862c1331ab1c19f93dd776e894404aebc6de14b85 blob 26 33 373a06a3e45fb33f83522f2459baf4b2d6ebfc196bf tree 38 49 406ffd655096935b0b00e7eac2190ac0e61ea978e2e blob 33 40 4553a3cf98cad23cb084fa1753bee60e9f97d08e317 tree 38 49 4959b6f349ad11c58d0e930dd12134a3e536bf5b057 tree 38 48 54452cb6cdb81a64344370c918a301eb153035f915a blob 16 24 592non delta: 8 objectschain length = 1: 1 object.git/objects/pack/pack-57cbdc16b7fd157d77451245ef44ba68ea567e14.pack: ok 我们看看这两个文件是什么作用： .pack 是包文件，这个文件包含了从文件系统中移除的所有对象的内容 .idx是索引文件，这个文件包含了包文件的偏移信息值得注意的是，git不同于svn的是最后一个版本保存的是完成的文件内容，之前的版本保存的是差异部分，因为git认为这样更高效。 总结我们分析了Git的内部机理，我们来总结一下： Git是一个内容寻址文件系统, 会对每一份内容生成校验和，以便通过校验和再次获取原有数据 Git本质是一个Key-Value数据存储方式 Git存在三个区：工作区，暂存区，版本库，我们操作git就是操作这三个区域 Git理论上会针对每一次修改创建一个副本，但是为了减少存储空间会压缩采用存储差异 Git内部包含这些对象: Tag, Commit(记录提交信息，上一次提交的指针,Tree指针), Tree(记录文件列表，Tree+Blob), Blob(内容对象)","tags":[{"name":"Git","slug":"Git","permalink":"https://cnkeep.github.io/tags/Git/"}]},{"title":"ssh协议配置免密码提交","date":"2018-03-07T00:34:00.000Z","path":"2018/03/07/06-ssh协议配置免密码提交/","text":"ssh协议配置免密码提交 标签：Git, ssh, windows 介绍我们平时在使用git进行版本控制时，为了避免每次都输入密码，可以为账号添加ssh key,这样就可以避免输入账号密码的繁琐步骤。 配置ssh key 笔者这里介绍windows环境(linux环境配置类似)，笔者本地配置了多个远程仓库服务，所以这里是一种通用的配置方式 1.生成公钥123456789101112131415161718192021222324252627282930#任意目录打开git bash##为账号生成公钥$ ssh-keygen -t rsa -C &apos;1348555156@qq.com&apos;Generating public/private rsa key pair.##指定公钥文件的生成位置，这里配置为用户的主目录（前面括号中提示的位置,.ssh为ssh相关的配置目录），文件名随意指定Enter file in which to save the key (/c/Users/zll/.ssh/id_rsa): /c/Users/zll/.ssh/personal_rsa## 键入密码，可选Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/zll/.ssh/personal_rsa.Your public key has been saved in /c/Users/zll/.ssh/personal_rsa.pub.The key fingerprint is:SHA256:e2fhKJwQ6vlWGjeHHXIUmoDefqnpGWBGt2XcieqiINs zhangleili@wxchina.comThe key&apos;s randomart image is:+---[RSA 2048]----+| .. .. || . o =.. || ...o B.o || ..o.*. o || =.+ S* .. || + +ooBooo . ||o + oO=oo + ||.+ . o=o o o ||. E o+ |+----[SHA256]-----+## 查看公钥$ cat /c/Users/zll/.ssh/personal_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDRxhEozNNvtwL+CauYrs5fXznTvHpjzneNUG4RtEVrCkIxn8ld4W9VuFJ9UbC3cKIxB43svDiQqdnDPM08A8RfGDX0Jt686orkk7DAJerEEewoYollxcz79CHy17DhJ58yyz7zhVWW9sht/H6hEZuulliTtZIvtieH3xnL0zZVt/VWKk42pC+L/gEPWNDI0nkgmkVpKHaTxX503+Vh6tGJFf92Xg+t7UnqE+zz2WvZ4XTtX1Fli1y3ES7xS7ZwU5LwreDSrgT0u8EIk5HLCwcS5//9ZHJgkBGY3cdrgN0BUviNdWnYd4fI+4/Qb0C+acuMb/1ow1VxEKlE+6YMr6B7 XXXXXX@wxchina.com 2.服务端配置ssh key 登录到服务端，将上一步中的cat **.pub的输出内容粘贴复制到服务端 3.配置不同的服务端账号和地址 1.配置用户 1234567891011121314151617181920# 配置用户$ git config --global --add user.name &quot;&lt;username&gt;&quot;$ git config --global --add user.email &quot;&lt;email&gt;&quot;或者vi ~/.gitconfig##增加name和email[user] name = ******* email = ********* name = ******** email = *********[http] sslVerify = false[url &quot;https://&quot;] insteadOf = git://[credential] helper = store 2.配置服务端地址123456789101112131415161718192021222324252627#进入用户主目录，第一步中有提示$ cd /c/Users/zll/.ssh/#新建config配置文件$ touch config$ vi config# 配置github.comHost github.com User cnkeep HostName github.com IdentityFile C:\\Users\\zll\\.ssh\\id_rsa PreferredAuthentications publickey # 配置私有gitlabHost 172.16.22.135 User zhangleili #指定用户，在~/.gitconfig中配置的用户名 HostName 172.16.22.135 #指定服务器地址 Port 4422 #指定服务器端口(默认22) IdentityFile C:\\Users\\zll\\.ssh\\personal_rsa #指定公钥的文件 PreferredAuthentications publickey #指定验证策略# 码云Host gitee.com HostName gitee.com IdentityFile C:\\Users\\zll\\.ssh\\mayun_rsa PreferredAuthentications publickey 3.测试配置是否可用123456$ ssh -T git@github.comWarning: Permanently added the RSA host key for IP address &apos;52.74.223.119&apos; to the list of known hosts.Hi cnkeep! You&apos;ve successfully authenticated, but GitHub does not provide shell access.$ ssh -T git@172.16.22.135 Welcome to GitLab, @cnkeep! 4.ssh方式拉取项目12345678910$ git clone ssh://git@172.16.22.135:4422/developer/test.gitCloning into &apos;test&apos;...The authenticity of host &apos;[172.16.22.135]:4422 ([172.16.22.135]:4422)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:yvJ524f2Cxd60O4onSsE4K8TAtgWQISzWM+g6wi+H7Y.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;[172.16.22.135]:4422&apos; (ECDSA) to the list of known hosts.remote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Total 3 (delta 0), reused 0 (delta 0)Receiving objects: 100% (3/3), done. 结束语 这些都是笔者在搭建私有gitlab是亲自测试过的操作，可能因为不同环境有所差异。如有错误欢迎指正！","tags":[{"name":"Git","slug":"Git","permalink":"https://cnkeep.github.io/tags/Git/"}]},{"title":"Https协议配置免输密码","date":"2018-03-05T21:29:00.000Z","path":"2018/03/06/05-Https协议配置免输密码/","text":"Https方式clone的项目每次都要输入用户名密码使用git从远程仓库clone下来的项目时，连接如果是https://, 而不是git@git (ssh)的形式时，我们每次git pull/push到远程仓库时，总提示需要输入账号和密码，太麻烦了，有没有办法呢？ 有！ 解决方案： 12git bash进入项目目录，输入：git config --global credential.helper store 完成配置后，再操作一次git pull, 然后提示输入账号密码，这次输入后就不需要再次输入密码了！","tags":[{"name":"Git","slug":"Git","permalink":"https://cnkeep.github.io/tags/Git/"}]},{"title":"提交规范","date":"2018-03-04T17:03:00.000Z","path":"2018/03/05/04-提交规范/","text":"Git的提交规范参考： 阮一峰-Commit message 和 Change log 编写指南 并非严格按照此规范执行，可以实际情况实际定制规则，主要为了规范化。 提交格式12345&lt;type&gt;(&lt;scope&gt;) : &lt;subject&gt; &lt;空行&gt; &lt;body&gt; &lt;空行&gt; &lt;footer&gt; 其中 type 的值可以有很多，下面有几个我们常用到的 feature :新功能 fixbug:修复bug doc : 文档改变 style : 代码格式改变 refactor :某个已有功能重构 performance:性能优化 test :增加测试 chore: 修改了改变构建流程、或者增加依赖库、工具等 build :改变了build工具 如 grunt换成了 npm revert: 撤销上一次的 commit scope :用来说明此次修改的影响范围 可以随便填写任何东西,我推荐使用下列 all ：表示影响面大 ，如修改了网络框架 会对真个程序产生影响 loation： 表示影响小，某个小小的功能 module：表示会影响某个模块 如登录模块、首页模块 、用户管理模块等等 subject: 用来简要描述本次改动，概述就好了body:具体的修改信息 应该尽量详细footer: 附加信息，例如fix #*;issue #;ref #*** 1234567891011示例： [feature](user): 新增用户管理 description: 针对用户…… 示例： [fixbug](sqlmapper): issue #1252 sql error desctiption: 修复sql问题 使用插件校验提交信息(validate-commit-msg)依赖：安装npm, 安装node, ghooks, validate-commit-msg 1.跳转到项目根目录下 2.安装ghooks123456npm install ghooks --save-dev``` &gt; 3.安装[validate-commit-msg](https://github.com/conventional-changelog-archived-repos/validate-commit-msg) ```textnpm install --save-dev validate-commit-msg 4.生成package.json1npm init --yes 5.添加hooks配置123456在package.json中增加：&quot;config&quot;: &#123; &quot;ghooks&quot;: &#123; &quot;commit-msg&quot;: &quot;validate-commit-msg&quot; &#125; &#125; 6.测试 规范化辅助插件(commitizen) 1.全局安装commitizennode模块1npm install -g commitizen 2.在项目目录下运行命令1commitizen init cz-conventional-changelog --save --save-exact 3.此时可能会报找不到package.json的错误,使用下面命令来自动生成一个项目的package,然后在运行2中的命令.1npm init --yes 4.运行完以上一律使用git cz 代替git commit来提交代码,同时会显示一下选项来自动生成符合格式的commit message.123456789101112131415$ git czcz-cli@2.10.1, cz-conventional-changelog@2.1.0Line 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters.? Select the type of change that you&apos;re committing: (Use arrow keys)&gt; feat: A new feature fix: A bug fix docs: Documentation only changes style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) refactor: A code change that neither fixes a bug nor adds a feature perf: A code change that improves performance test: Adding missing tests or correcting existing tests(Move up and down to reveal more choices)","tags":[{"name":"Git","slug":"Git","permalink":"https://cnkeep.github.io/tags/Git/"}]},{"title":"git的常见命令","date":"2018-03-03T16:42:00.000Z","path":"2018/03/04/03-git的常见命令/","text":"Git的简单使用前言&emsp;&emsp;开发过程当中难以避免的要使用到版本控制工具，以前使用的SVN, 但随着Git的出现，它以及其优良的特性迅速火热，本节我们就来简单了解一下。 介绍&emsp;&emsp;Git是一个开源的分布式版本控制系统(本质是一个内容寻址文件系统，后面章节会做介绍)，用于敏捷高效地处理任何或小或大的项目。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（这点很重要，他可以在服务端无法访问的时候提交到本地仓库，等网络恢复后推送到远程仓库）。 Git 与 SVN的区别 简单使用初始化命令 init 初始化仓库1$ git init clone 克隆仓库12$ git clone https://github.com/repname$ git clone https://github.com/repname myrep #myrep作为本地仓库名 config 配置1234$ git config --list #查看配置$ git config --system user.name #系统级配置$ git config --global user.name #全局配置，系统用户级$ git config user.name #仓库级配置 remote 远程仓库12345$ git remote -v #查看远程仓库详细信息$ git remote show origin #查看远程仓库$ git remote add pb https://github.com/pb #添加远程仓库映射$ git remote rename pb paul #重命名远程仓库映射$ git remote rm paul #移除远程仓库映射关系 ### 基础命令 status 查看文件状态123$ git status$ git status -s #状态简览$ git ls-files --stage #查看缓存区索引文件内容，即.git/index add 暂存已修改文件12$ git add filename$ git add -A #暂存所有已修改文件 commit 提交更新12$ git commit -m &quot;commit message&quot;$ git commit -a -m &quot;commit message&quot; #跳过暂存区，直接提交 push 推送到远程仓库12$ git push$ git push origin master #将本地master分支推动到远程origin仓库 fetch 从远程仓库拉取数据1$ git fetch [remote-name] merge 合并分支123$ git merge --no-ff #推荐的合并方式，会做作一个新的提交，便于历史查询 $ git merge hotfix #把 hotfix 分支，合并到当前分支$ git mergetool #图形化解决冲突的工具 pull ( fetch + merge ) 常用命令 diff 查看修改12$ git diff #比较 暂存区－工作区$ git diff --staged #比较 仓库－暂存区 log 查看提交历史1234567$ git log$ git log --stat #展示提交的简略统计信息$ git log --oneline #简要显示$ git log --grep #类似grep命令，支持正则查找$ git log --since/after/before/until #只是时间点查找$ git log $ git reflog #回退版本后看不到之后的历史记录，此命令可以完成该功能 撤销操作12345$ git commit --amend #重新提交$ git reset HEAD filename #取消暂存的文件$ git reset -soft #暂存区-&gt;工作区, 类似于checkout$ git reset --mixed #版本库-&gt;暂存区 $ git reset --hard #版本库-&gt;暂存区-&gt;工作区 checkout1234567$ git checkout &lt;filename&gt;# 会覆盖工作区文件# 如果暂存区有改动的文件，则从暂存区到工作区# 如果暂存区无改动的文件，则从仓库到工作区#新建分子并切换至新分支$ git checkout -b &lt;branch_name&gt; tag 打标签1234567$ git tag #查看标签$ git tag -a v1.4 -m &quot;my version 1.4&quot; #创建附注标签$ git tag v1.4 #创建轻量标签$ git tag -a v1.2 9fceb02 #对某次提交后期打标签$ git push origin v1.5 #上传某个标签，GIT 默认不会 push 标签到远程仓库$ git push origin --tags #上传所有不在远程仓库的标签$ git checkout -b version2 v2.0.0 #检出标签 rm 移除文件12$ git rm filename #个人感觉效果同 rm$ git rm --cached filename #移除暂存区中的文件 分支命令 branch 创建分支123456789$ git branch #查看分支，前面带星号*的，是当前分支$ git branch testing #创建 testing 分支$ git branch -d testing #删除 testing 分支$ git branch -v #查看每个分支最后一次提交$ git branch --merged #查看已合并到当前分支的分支$ git branch --no-merged #查看未合并到当前分支的分支$ git branch -r #查看远程分支$ git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; #推送本地分支到远程分支，不存在时新建远程分支$ git push origin :&lt;remote_branch&gt; #与上一条不同的时本地分支留空了，这将会删除远程分支 checkout 切换分支12$ git checkout testing$ git checkout -b iss53 #创建分支，并切换到新创建的分支 底层命令 cat-file 读取 GIT 仓库对象1234$ git cat-file -p f8a67de1d4bf0d6dbaaaf8990ffe8394e5fa88ee #查看对象内容$ git cat-file -p master^&#123;tree&#125; #master 分支上最新的提交所指向的 tree 对象$ git cat-file -t f8a67de1d4bf0d6dbaaaf8990ffe8394e5fa88ee #查看对象类型$ git cat-file -s f8a67de1d4bf0d6dbaaaf8990ffe8394e5fa88ee #查看对象大小 gc 生成包文件1234$ git gc#作用：完整保存最新版文件，历史版本文件保存差异#GIT 会根据情况自己执行，一般不需要手动之行$ git verify-pack -v .git/objects/pack/pack-57cbdc16b7fd157d77451245ef44ba68ea567e14.idx 查看对象 $ find .git/object/ -type f #所有对象列表 $ git rev-list --objects --all #blob列表","tags":[{"name":"Git","slug":"Git","permalink":"https://cnkeep.github.io/tags/Git/"}]},{"title":"git和svn有什么区别","date":"2018-03-01T16:40:00.000Z","path":"2018/03/02/02-git和svn有什么区别/","text":"Git和Svn的区别以前有Svn这种工具来进行版本控制，为什么还要用Git呢，两者有什么区别? 其实Git和Svn都是版本控制工具，但是Git更倾向于分布式，而且效率高，功能更强大。 Git和Svn的主要差别： 在Git 中的绝大多数操作都只需要访问本地文件和资源，不必联网就可以看到所有的历史版本记录，而SVN 却需要联网。 &nbsp;&nbsp;因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快，但我们需要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。如果想要看当前版本的文件和一个月前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算。 SVN 断开网络或者断开VPN就无法commit代码，但是Git 可以先commit到本地仓库, svn断网就傻了 Git 克隆一个完整项目的速度非常快，SVN 非常慢。 Git 只关心文件数据的整体是否发生变化，而SVN这类版本控制系统则只关心文件内容的具体差异。 &nbsp;&nbsp;这类系统（如SVN）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，然而Git 并不保存这些前后变化的差异数据。实际上，Git更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。 Git分支管理比svn强大太多 在 SVN 这类的版本控制系统上，分支（branch）是一个完整的目录，且这个目录拥有完整的实际文件。如果工作成员想要开启新的分支，那将会影响“全世界”！每个人都会拥有和你一样的分支。如果你的分支是用来对系统模块进行安全检查测试的，那将会像传染病一样，你改一个分支，还得让其他人重新切分支重新下载，而且这些代码很可能对稳定版本还是具有破坏性的。 在 Git上，每个工作成员可以任意在自己的本地版本库开启无限个分支。举例：当我想尝试破坏自己的程序（安检测试），并且想保留这些被修改的文件供日后使用，我可以开一个分支，做我喜欢的事。完全不需担心妨碍其他工作成员。只要我不合并及提交到主要版本库，没有一个工作成员会被影响。等到我不需要这个分支时， 我只要把它从我的本地版本库删除即可，无痛无痒。","tags":[{"name":"Git","slug":"Git","permalink":"https://cnkeep.github.io/tags/Git/"}]},{"title":"git是什么","date":"2018-03-01T13:23:00.000Z","path":"2018/03/01/01-git是什么/","text":"Git是什么？ 作为一个Coder, 在编写代码过程中不可避免的要提交和修改文件，如何没有版本控制工具，我们想象一下，不小心删除了代码，恢复不了，昨天改了哪些，总会遇到这样对我问题，哪有没有一种工具能保存我们的历史修改记录，方便我们自由的切换到任意一个版本呢？ &nbsp;&nbsp;Git就是这样一个分布式版本控制工具, 能帮助我们记录文件的历史修改记录，可以自由的切换到文件的历史版本，再也不怕文件丢了！当然git远不止做了这些，它还提供了各种对比，合并，统计的功能。","tags":[{"name":"Git","slug":"Git","permalink":"https://cnkeep.github.io/tags/Git/"}]}]