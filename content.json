[{"title":"Hello World","date":"2019-03-28T03:45:41.057Z","path":"2019/03/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"tcpdump的使用","date":"2018-07-22T01:33:00.000Z","path":"2018/07/22/19-tcpdump的使用/","text":"tcpdump抓包工具的使用1. 介绍&nbsp;&nbsp;面对一些线上的网络问题排查时，经常需要抓取网络数据包进行分析，windows有大名鼎鼎的winshark, 而在linux就少有图形化的抓包工具，幸好有tcpdump工具的存在。 &nbsp;&nbsp; 它可以使用定义的规则抓取网卡上的数据包，便于我们分析数据。 2. 抓包原理2.1 原理介绍 抓包原理 Linux抓包是通过注册一种虚拟的底层网络协议来完成对网络报文(准确的说是网络设备)消息的处理权。当网卡接收到一个网络报文之后，它会遍历系统中所有已经注册的网络协议，当抓包模块把自己伪装成一个网络协议的时候，系统在收到报文的时候就会给这个伪协议一次机会，让它来对网卡收到的报文进行一次处理，此时该模块就会趁机对报文进行窥探，也就是把这个报文完完整整的复制一份，假装是自己接收到的报文，汇报给抓包模块。 注意事项 必须使用root身份执行 要抓取其他主机的数据包，需要开启混杂模式，即抓取任何经过它的数据包，不管这个数据包是不是发给它或者是它发出的。一般而言，Unix不会让普通用户设置混杂模式，因为这样可以看到别人的信息，比如telnet的用户名和密码，这样会引起一些安全上的问题，所以只有root用户可以开启混杂模式，开启混杂模式的命令是：ifconfig en0 promisc, en0是你要打开混杂模式的网卡。 2.2 命令介绍1. 命令格式12345678tcpdump [ -AdDefIKlLnNOpqRStuUvxX ] [ -B buffer_size ] [ -c count ] [ -C file_size ] [ -G rotate_seconds ] [ -F file ] [ -i interface ] [ -m module ] [ -M secret ] [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ] [ -W filecount ] [ -E spi@ipaddr algo:secret,... ] [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ] [ expression ] 2. 选项介绍-A：以ASCII编码打印每个报文（不包括链路层的头），这对分析网页来说很方便-a：将网络地址和广播地址转变成名字-c&lt;数据包数目&gt;：在收到指定的包的数目后，tcpdump就会停止-C：用于判断用 -w 选项将报文写入的文件的大小是否超过这个值，如果超过了就新建文件（文件名后缀是1、2、3依次增加）-d：将匹配信息包的代码以人们能够理解的汇编格式给出-dd：将匹配信息包的代码以c语言程序段的格式给出-ddd：将匹配信息包的代码以十进制的形式给出-D：列出当前主机的所有网卡编号和名称，可以用于选项 -i-e：在输出行打印出数据链路层的头部信息-f：将外部的Internet地址以数字的形式打印出来-F&lt;表达文件&gt;：从指定的文件中读取表达式,忽略其它的表达式-i&lt;网络界面&gt;：监听主机的该网卡上的数据流，如果没有指定，就会使用最小网卡编号的网卡（在选项-D可知道，但是不包括环路接口），linux 2.2 内核及之后的版本支持 any 网卡，用于指代任意网卡-l：如果没有使用 -w 选项，就可以将报文打印到 标准输出终端（此时这是默认）-n：显示ip，而不是主机名-N：不列出域名-O：不将数据包编码最佳化-p：不让网络界面进入混杂模式-q：快速输出，仅列出少数的传输协议信息-r&lt;数据包文件&gt;：从指定的文件中读取包(这些包一般通过-w选项产生)-s&lt;数据包大小&gt;：指定抓包显示一行的宽度，-s0表示可按包长显示完整的包，经常和-A一起用，默认截取长度为60个字节，但一般ethernet MTU都是1500字节。所以，要抓取大于60字节的包时，使用默认参数就会导致包数据丢失-S：用绝对而非相对数值列出TCP关联数-t：在输出的每一行不打印时间戳-tt：在输出的每一行显示未经格式化的时间戳记-T&lt;数据包类型&gt;：将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议）-v：输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息-vv：输出详细的报文信息-x:/-xx/-X/-XX：以十六进制显示包内容，几个选项只有细微的差别，详见man手册-w:&lt;数据包文件&gt;：直接将包写入文件中，并不分析和打印出来expression：用于筛选的逻辑表达式； 3. 常用选项 抓取指定数目的包(-c选项) 默认情况下tcpdump将一直抓包，直到按下”ctrl+c”中止，使用-c选项可以指定抓包的数量。 将抓到包写入文件中(-w选项) 使用-w选项，可将抓包记录到一个指定文件中，以供后续分析 读取tcpdump保存文件(-r选项) 对于保存的抓包文件，可以使用-r选项进行读取 抓包时不进行域名解析(-n选项) 默认情况下，tcpdump抓包结果中将进行域名解析，显示的是域名地址而非ip地址，使用-n选项，可指定显示ip地址。 显示完整的包(-s0) 4. 表达式介绍 表达式是一个正则表达式，tcpdump利用它作为过滤报文的条件，如果一个报文满足表达式的条件，则这个报文将会被捕获。如果没有给出任何条件，则网络上所有的信息包将会被截获。在表达式中一般如下几种类型的关键字: 类型关键字主要包括host，net，port，缺省是host 传输方向关键字主要包括src（源地址）, dst(目标地址) ,dst or src, dst and src, 缺省是src or dst 协议关键字主要包括fddi,ip ,arp,rarp,tcp,udp等类型 3. 示例1. 监视指定网络接口的数据包 12# tcpdump -i eth1 如果不指定网卡，默认tcpdump只会监视第一个网络接口上所有流过的数据包，一般是eth0，下面的例子都没有指定网络接口。 2. 监视指定主机的数据包12345678910111213141516171819202122232425截获所有210.27.48.1 的主机收到的和发出的所有的数据包 # tcpdump host 210.27.48.1``` ### 3. TCP连接 这里通过telnet工具连接redis测试tcp连接的报文抓取 ```text [root@localhost redis-5.0.3]# tcpdump -i eth1 -v -s 0 port 6379 tcpdump: listening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes[1] 21:56:41.602246 IP (tos 0x0, ttl 64, id 54118, offset 0, flags [DF], proto TCP (6), length 52)[2] 172.16.22.235.54586 &gt; localhost.localdomain.6379: Flags [S], cksum 0xbe8b (correct), seq 1436544059, win 64240, options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0[3] 21:56:41.602294 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 52)[4] localhost.localdomain.6379 &gt; 172.16.22.235.54586: Flags [S.], cksum 0x85b9 (incorrect -&gt; 0xdaf5), seq 3525089865, ack 1436544060, win 29200, options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0[5] 21:56:41.602446 IP (tos 0x0, ttl 64, id 54119, offset 0, flags [DF], proto TCP (6), length 40)[6] 172.16.22.235.54586 &gt; localhost.localdomain.6379: Flags [.], cksum 0x85d3 (correct), ack 1, win 2053, length 0[7] 21:56:48.665457 IP (tos 0x0, ttl 64, id 54123, offset 0, flags [DF], proto TCP (6), length 40)[8] 172.16.22.235.54586 &gt; localhost.localdomain.6379: Flags [F.], cksum 0x85d2 (correct), seq 1, ack 1, win 2053, length 0[9] 21:56:48.665797 IP (tos 0x0, ttl 64, id 58678, offset 0, flags [DF], proto TCP (6), length 40)[10] localhost.localdomain.6379 &gt; 172.16.22.235.54586: Flags [F.], cksum 0x85ad (incorrect -&gt; 0x8cf1), seq 1, ack 2, win 229, length 0[11] 21:56:48.666220 IP (tos 0x0, ttl 64, id 54124, offset 0, flags [DF], proto TCP (6), length 40)[12] 172.16.22.235.54586 &gt; localhost.localdomain.6379: Flags [.], cksum 0x85d1 (correct), ack 2, win 2053, length 0 ^C 6 packets captured 16 packets received by filter 0 packets dropped by kernel 分析12345678[1]~[6] 3次握手 [7]~[12] 4次挥手拿[1]来看，proto： 指明协议是TCPlength：报文长度srcHost:srcPort &gt; destHost:destPort :指明源地址端口和目标地址端口Flags[*]: 指明包类型，S代表SYN; .代表ACK; F代表FIN","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"EOF的使用","date":"2018-07-22T00:20:00.000Z","path":"2018/07/22/18-EOF的使用/","text":"Linux下EOF的使用1. 介绍如果我们需要往一个文件里自动输入N行内容。如果是少数的几行内容，还可以用echo追加方式，但如果是很多行，那么单纯用echo追加的方式就显得复杂了，这时候就可以使用EOF结合cat命令进行内容的追加了。 2. 用法123&lt;&lt;EOF ...EOF 通过cat配合重定向能够生成文件并追加操作,在它之前先熟悉几个特殊符号:&lt; :输入重定向&gt; :输出重定向&gt;&gt; :输出重定向,进行追加,不会覆盖之前内容&lt;&lt; :标准输入来自命令行的一对分隔号的中间内容. 3.示例1234567# cat &lt;&lt;EOF&gt;test.sh&gt; ssss&gt; lllll&gt; EOF# more test.sh sssslllll","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"which_where_find","date":"2018-07-19T21:11:00.000Z","path":"2018/07/20/17-which_where_find/","text":"which, whereis, find的区别","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"挂载","date":"2018-07-19T17:55:00.000Z","path":"2018/07/20/16-挂载/","text":"https://blog.csdn.net/csh86277516/article/details/78844830https://blog.csdn.net/qq_39521554/article/details/79501714","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"proc目录探查系统信息","date":"2018-07-18T14:52:00.000Z","path":"2018/07/18/16-proc目录探查系统信息/","text":"/proc目录探查系统信息 标签：/proc 介绍/proc 文件系统下的多种文件提供的系统信息不是针对某个特定进程的, 而是能够在整个系统范围的上下文中使用。可以使用的文件随系统配置的变化而变化。命令procinfo 能够显示基于其中某些文件的多种系统信息。包含：内存，硬盘等 使用 CPU1$ cat /proc/cpuinfo Memory12$ cat /proc/meminfo$ free -m 硬盘12$ fdisk -l$ df -h 其他 123456netstat -lntp # 查看所有监听端口 netstat -antp # 查看所有已经建立的连接 w # 查看活动用户 id # 查看指定用户信息 last # 查看用户登录日志 rpm -qa # 查看所有安装的软件包","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"yum工具配置","date":"2018-07-16T14:48:00.000Z","path":"2018/07/16/15-yum工具配置/","text":"yum工具配置介绍yum是一款软件包管理器，能够从指定的服务器自动下载RPM包并且安装，还可以自动处理依赖性关系，yum提供了查找、安装、删除某一个，一组甚至全部软件包的命令，而且命令简洁而又好记。 常用命令介绍 1.查找与显示123456# 查找软件yum search &lt;package&gt;#显示安装包信息yum info &lt;package&gt;#显示已经安装和可以安装的程序包yum list 2.安装1yum install &lt;package&gt; 3.更新与升级12345#更新yum update [&lt;package&gt;]#升级程序yum upgrade &lt;package&gt; 4.移除程序1234#移除程序包yum remove &lt;package&gt;##查看依赖yum deplist &lt;package&gt; 5.缓存12345#缓存清除yum clean #生成缓存yum makecache 配置及目录介绍 1.配置文件/etc/yum.conf 1234567891011121314151617181920212223242526[main]cachedir=/var/cache/yum/$basearch/$releaseverkeepcache=0debuglevel=2logfile=/var/log/yum.logexactarch=1obsoletes=1gpgcheck=1plugins=1installonly_limit=5bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yumdistroverpkg=centos-release# This is the default, if you make this bigger yum won&apos;t see if the metadata# is newer on the remote and so you&apos;ll &quot;gain&quot; the bandwidth of not having to# download the new metadata and &quot;pay&quot; for it by yum not having correct# information.# It is esp. important, to have correct metadata, for distributions like# Fedora which don&apos;t keep old packages around. If you don&apos;t like this checking# interupting your command line usage, it&apos;s much better to have something# manually check the metadata once an hour (yum-updatesd will do this).# metadata_expire=90m# PUT YOUR REPOS HERE OR IN separate files named file.repo# in /etc/yum.repos.d 简单介绍一下： cachedir: yum缓存目录，yum在此存储下载的rpm包和数据库 logfile: 日志文件 2.镜像仓库配置目录/etc/yum.repos.d/123$ ls /etc/yum.repos.d/Centos-7.repo CentOS-CR.repo CentOS-fasttrack.repo CentOS-Sources.repo docker-ce.repo_bakCentOS-Base.repo_bak CentOS-Debuginfo.repo CentOS-Media.repo CentOS-Vault.repo 该目录下面的配置文件指明了镜像的源地址配置，我们可以在此配置新的镜像源地址 3.插件等其他的配置文件目录/etc/yum/yum/12$ ls /etc/yum/yum/fssnap.d pluginconf.d protected.d vars version-groups.conf 这里重点介绍pluginconf.d/目录是相关插件的配置目录，后面介绍的fastestmirror插件配置文件就在这里 拓展添加源添加阿里的镜像源 123#配置域名解析# vi /etc/resolve.conf nameserver 8.8.8.8 方式一：12345678910#备份原有配置$ mv /etc/yum.repos.d/Centos-7.repo /etc/yum.repos.d/Centos-7.repo.bak# 下载阿里镜像配置$ sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/repo/Centos-7.repo#清理缓存$ sudo yum clean#构建缓存$ sudo yum makecache 方式二:123456789#备份原有配置$ mv /etc/yum.repos.d/Centos-7.repo /etc/yum.repos.d/Centos-7.repo.bak# 下载阿里镜像配置$ wget http://mirrors.aliyun.com/repo/Centos-7.repo$ mv Centos-7.repo /etc/yum.repos.d/Centos-7.repo#清理缓存$ sudo yum clean all#构建缓存$ sudo yum makecache 方式三：12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 查看缓存存储路径$ yum-config-manager|grep base_persistdirpersistdir = /var/lib/yum/repos/x86_64/7base_persistdir = /var/lib/yum/repos/x86_64/7base_persistdir = /var/lib/yum/repos/x86_64/7$ cd /var/lib/yum/repos/x86_64/7$ vi /etc/yum.conf [main] cachedir=/var/cache/yum/$basearch/$releasever keepcache=0 debuglevel=2 logfile=/var/log/yum.log exactarch=1 obsoletes=1 gpgcheck=1 plugins=1 #将plugins的值修改为0 installonly_limit=5$ sudo yum install yum-plugin-fastestmirror$ vi /etc/yum/pluginconf.d/fastestmirror.conf [main] enabled=1 #配置为1 verbose=0 always_print_best_host = true socket_timeout=3 # Relative paths are relative to the cachedir (and so works for users as well # as root). hostfilepath=timedhosts.txt maxhostfileage=10 maxthreads=15 #exclude=.gov, facebook #include_only=.nl,.de,.uk,.ie $ vi /var/cache/yum/x86_64/7/timedhosts.txt #加入下列内容 mirrors.aliyuncs.com 99999999999 mirrors.cloud.aliyuncs.com 99999999999 mirrors.aliyun.com 2.03075098991#清理缓存$ sudo yum clean all#构建缓存$ sudo yum makecache","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"开机启动项","date":"2018-07-15T11:41:00.000Z","path":"2018/07/15/14-开机启动项/","text":"开机启动项 标签：Redis, systemctl, chkconfig参考：Linux实现开机自动运行普通用户脚本参考：systemctl管理Redis启动、停止、开机启动 前言最近在玩Redis时，因为是放在虚拟机里跑的，但是虚拟机需要经常关机和开机，导致每次都要手动重启redis, 但是我受够了想让它开机自启，于是就有了今天的内容。 设置开机自启方案方案一:使用/etc/rc.d/rc.local自启动脚本文件实现开机自动运行普通用户脚本。 把需要开机启动的脚本程序直接写入/etc/rc.d/rc.local文件中，这样子开机时就会自动执行这些脚本程序，运行对应的服务程序。需要在root环境下编辑。 方案二:使用chkconfig和/etc/init.d 我们都了解/etc/init.d目录下的所有文件都是脚本文件，这个目录下的脚本文件，在设置到开机自启动后，会在开机时自动执行。 1.root账号编写自启动脚本12345678$ vi /etc/init.d/redis#!/bin/bash# redis auto start scripts#chkconfig: 235 80 30 --235指定的启动级别，在哪写启动级别下启动；--80 启动的优先级；--30 关闭的优先级su /usr/local/app/redis-5.0.3/src/redis-server /usr/local/app/redis-5.0.3/redis.conf --daemonize no 等级0表示：表示关机等级1表示：单用户模式等级2表示：无网络连接的多用户命令行模式等级3表示：有网络连接的多用户命令行模式等级4表示：不可用等级5表示：带图形界面的多用户模式等级6表示：重新启动 2.添加执行权限1$ chmod +x /etc/init.d/redis 3.加入启动项配置1234#假如启动项$ chkconfig --add redis #设置开机启动$ chkconfig redis on 4.查看启动项1$ chkconfig --list 方案三(推荐):使用systemctl和/lib/systemd/system/ 1.编写脚本1234567891011121314$ vi /lib/systemd/system/redis.service#写入以下内容[Unit]Description=Redis_5.0.1After=network.target[Service]#redis安装绝对路径ExecStart=/usr/local/app/redis-5.0.3/src/redis-server /usr/local/app/redis-5.0.3/redis.conf --daemonize noExecStop=/usr/local/app/redis-5.0.3/src//redis-cli -h 127.0.0.1 -p 6379 shutdown[Install]WantedBy=multi-user.target [Unit] 表示这是基础信息 Description 是描述 After 是在那个服务后面启动，一般是网络服务启动后启动 [Service] 表示这里是服务信息 ExecStart 是启动服务的命令 ExecStop 是停止服务的指令 [Install] 表示这是是安装相关信息 WantedBy 是以哪种方式启动：multi-user.target表明当系统以多用户方式（默认的运行级别）启动时，这个服务需要被自动运行。 详细请移步至：CoreOS实践指南（八）：Unit文件详解 2.设置开机启动123456789$ ln -s /lib/systemd/system/redis.service /etc/systemd/system/multi-user.target.wants/redis.service#刷新配置$ systemctl daemon-reload#开启开机自启功能$ systemctl enable redis$ systemctl [start|stop|restart|status] redis 3.查看启动项1$ systemctl list-unit-files *","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"wc命令","date":"2018-07-15T08:26:00.000Z","path":"2018/07/15/13-wc命令/","text":"1234567891011wc -l #统计行数 -c, --bytes print the byte counts -m, --chars print the character counts -l, --lines print the newline counts --files0-from=文件 从指定文件读取以NUL 终止的名称，如果该文件被 指定为&quot;-&quot;则从标准输入读文件名 -L, --max-line-length 显示最长行的长度 -w, --words 显示单词计数 --help 显示此帮助信息并退出 --version 显示版本信息并退出","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"echo转义&&换行","date":"2018-07-14T06:23:00.000Z","path":"2018/07/14/12-echo转义&&换行/","text":"echo中的转义与换行经常使用echo命令，但是不知道怎么转义可不换行，今天用到了，做一下笔记。 1.原样输出(使用单引号)12345678910111213echo &apos;$name \\n end&apos;#output:# $name \\n end``` &gt; 2.显示转义字符(-e) ```textecho -e &apos;$name \\n end&apos;#output:# $name # end 3.不换行(\\c)12345echo -e &quot;$name \\n end \\c&quot; &amp;&amp; echo &quot;===&quot; #output:# $name # end ===","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"head&tail命令","date":"2018-07-13T05:05:00.000Z","path":"2018/07/13/11-head&tail命令/","text":"head &amp; tail命令命令功能&nbsp;&nbsp;倒序或者顺序查看文件内容 命令格式12$tail [filename]$head [filename] 常用参数示例 倒序查看100行1$tail -n 100 [filename] 倒序查看文件动态刷新，用于日志观察1$tail -f [filename] 查看文件前10行1$head -n 10 [filename]","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"vi命令","date":"2018-07-12T02:47:00.000Z","path":"2018/07/12/10-vi命令/","text":"vi命令命令功能&nbsp;&nbsp;vi命令是linux提供的强大的文本编辑工具，接下来我们就常用的功能做一下记录(非全部)。 vi查找 当你用vi打开一个文件后，因为文件太长，如何才能找到你所要查找的关键字呢？ /或者?,在命令模式下敲斜杆(/)这时在状态栏（也就是屏幕左下脚）就出现了 “/”然后输入你要查找的关键字敲回车就可以了。如果你要继续查找此关键字，敲字符n就可以继续查找了。值得注意的是“/”是向下查找，而“?”是向上查找，而在键盘定义上“?”刚好是“/”的上档符。 vi替换： vi/vim 中可以使用 ：s 命令来替换字符串以前只会使用一种格式来全文替换，这里只说部分 123456：s/vivian/sky/ 替换当前行第一个 vivian 为 sky：s/vivian/sky/g 替换当前行所有 vivian 为 sky：n,$s/vivian/sky/ 替换第 n 行开始到最后一行中每一行的第一个 vivian 为 sky：n,$s/vivian/sky/g 替换第 n 行开始到最后一行中每一行所有 vivian 为 sky n 为数字，若 n 为 .，表示从当前行开始到最后一行：%s/vivian/sky/（等同于：g/vivian/s//sky/）替换每一行的第一个 vivian 为 sky：%s/vivian/sky/g（等同于：g/vivian/s//sky/g）替换每一行中所有 vivian 为 sky 鼠标移动操作12345命令模式下``H,J,K,L``字符可以实现鼠标跳转，这几个键都是紧挨着的，操作多方便哦！ H:向前移动J:向下移动K:向上移动L:向后移动 行数操作12345#显示行号:set nu跳转到第10行:10 翻页12Ctrl+B: 上一页Ctrl+F: 下一页 复制，粘贴，撤销，删除1234yy: 复制当前行p: 粘贴u: 撤销更改dd: 删除","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"user_group_chmod命令","date":"2018-07-11T01:36:00.000Z","path":"2018/07/11/09-user_group_chmod命令/","text":"user相关 &amp; group相关 &amp; chmod命令 本文中的命令参数选项并非全部选项，仅包含常用选项 用户系统&emsp;&emsp;linux是一个多用户多任务的系统，它有用户，用户组的概念，一个用户必须属于一个组。 user相关 与用户相关的配置文件1234567891011121314151617181920212223242526272829303132333435/etc/passwd 用户的配置文件/etc/shadow 用户的影子口令``` &gt; 与用户相关的命令 ```text1. useradd 功能：新建用户 用法：useradd [选项] 登录 useradd -D useradd -D [选项] 选项： -b, --base-dir BASE_DIR 新账户的主目录的基目录 -d, --home-dir HOME_DIR 新账户的主目录 -e, --expiredate EXPIRE_DATE 新账户的过期日期 -f, --inactive INACTIVE 新账户的密码不活动期 -g, --gid GROUP 新账户主组的名称或 ID -G, --groups GROUPS 新账户的附加组列表 -m, --create-home 创建用户的主目录 -M, --no-create-home 不创建用户的主目录 -p, --password PASSWORD 加密后的新账户密码 -r, --system 创建一个系统账户 示例： $ useradd -g zll_group -G root zll #新建用户zll, 用户主组zll_group, 附组root $ passwd zll #设置密码 $ id zll #查看用户zll的组 uid=1122(zll_group) gid=1125(zll_group) groups=1125(zll_group),0(root) $ useradd -s /sbin/nologin test #创建一个不能登录的用户2. usermod 功能：修改用户3. userdel 功能：删除用户 group相关 group相关配置文件 1/etc/group group相关命令 123456789101112131415161. groupadd 功能：新建用户组 用法：groupadd [选项] 用户组 选项： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。 示例： $ groupadd zll_group2. groupmod 功能：修改用户组3. groupdel 功能：删除用户组 文件权限&emsp;&emsp;linux的文件系统拥有严格访问权限，文件的可读可写，所属人，所属组都有严格的限制，我们也可以人为控制修改，这时候就要用到chmod命令了。我们先看看文件都有什么权限：123456789101112131415161718192021222324252627282930311：代表文件类型，为目录是为d2: 代表文件的宿主权限，由三位表示，4：可读，2：可写，1：可执行 3：代表文件的所属组权限4：代表其他用户的权限5：代表文件的所属用户6：代表文件的所属组``` &gt; chmod命令可以修改文件的相关权限 ```text语法： chmod [-cfvR] [--help] [--version] mode file...参数说明： [ugoa...][[+-=][rwxX]...][,...] 其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作 -f : 若该文件权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更) --help : 显示辅助说明 --version : 显示版本 示例： $ chmod +x start.sh #增加执行权限 chown可以修改文件的饿所属者 12345678910111213141516171819语法 chown [-cfhvR] [--help] [--version] user[:group] file...参数 : user : 新的文件拥有者的使用者 ID group : 新的文件拥有者的使用者组(group) -c : 显示更改的部分的信息 -f : 忽略错误信息 -h :修复符号链接 -v : 显示详细的处理信息 -R : 处理指定目录以及其子目录下的所有文件 --help : 显示辅助说明 --version : 显示版本实例 #将文件 file1.txt 的拥有者设为 users 群体的使用者 runoob : $ chown runoob:users file1.txt #将目前目录下的所有文件与子目录的拥有者皆设为 users 群体的使用者 lamport : $ chown -R lamport:users *","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"sed命令","date":"2018-07-10T22:20:00.000Z","path":"2018/07/11/08-sed命令/","text":"sed命令[注：文中的命令参数列表至列出了常用的几个，并不是全部] sed命令 功能 &emsp;&emsp;sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用, 可以完成文件内容的批量替换，删除等。 使用方式及参数列表 1234567891011121314151617181920212223242526sed [options] &apos;command&apos; file(s)参数列表： g 表示行内全面替换。 p 表示打印行。 i 修改源文件 w 表示把行写入一个文件。 x 表示互换模板块中的文本和缓冲区中的文本。 y 表示把一个字符翻译为另外的字符（但是不用于正则表达式） \\1 子串匹配标记 &amp; 已匹配字符串标记 匹配模式： ^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。 $ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。 . 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。 * 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 [] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。 \\(..\\) 匹配子串，保存匹配的字符，如s/\\(love\\)able/\\1rs，loveable被替换成lovers。 &amp; 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成**love**。 \\&lt; 匹配单词的开始，如:/\\&lt;love/匹配包含以love开头的单词的行。 \\&gt; 匹配单词的结束，如/love\\&gt;/匹配包含以love结尾的单词的行。 x\\&#123;m\\&#125; 重复字符x，m次，如：/0\\&#123;5\\&#125;/匹配包含5个0的行。 x\\&#123;m,\\&#125; 重复字符x，至少m次，如：/0\\&#123;5,\\&#125;/匹配至少有5个0的行。 x\\&#123;m,n\\&#125; 重复字符x，至少m次，不多于n次，如：/0\\&#123;5,10\\&#125;/匹配5~10个0的行。 示例 12345678910111.选项-i,匹配file文件中每一行的第一个book替换为books： $ sed -i &apos;s/book/books/g&apos; file2.-n选项和p命令一起使用表示只打印那些发生替换的行： $ sed -n &apos;s/test/TEST/p&apos; file 3.使用后缀 /g 标记会替换每一行中的所有匹配： $ sed &apos;s/book/books/g&apos; file #不会修改源文件 4.替换文件中所有的6379为6380并生成新文件 $ sed &apos;s/6379/6380/g&apos; redis.conf &gt; redis-6380.conf","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"时间同步","date":"2018-07-09T22:04:00.000Z","path":"2018/07/10/07-时间同步/","text":"Centos7时间不同步总是早8小时转载-CentOS 7系统时间与实际时间差8个小时 问题场景&emsp;&emsp;自己安装在虚拟机中的Centos时间总是早8个小时，每次都需要我手动改，太麻烦，今天终于决定彻底结局它。 结局方案123456789101112131415161718192021222324252627282930313233$ timedatectl #查看时间 Local time: 三 2018-10-24 23:30:48 CST Universal time: 三 2018-10-24 15:30:48 UTC RTC time: 三 2018-10-24 15:30:48 Time zone: Asia/Shanghai (CST, +0800) NTP enabled: n/aNTP synchronized: no RTC in local TZ: no DST active: n/a $ ls /usr/share/zoneinfo/ #查看时区列表Africa Australia Cuba Etc GMT-0 Indian Kwajalein Navajo posix ROK UTCAmerica Brazil EET Europe GMT+0 Iran Libya NZ posixrules Singapore WETAntarctica Canada Egypt GB Greenwich iso3166.tab MET NZ-CHAT PRC Turkey W-SUArctic CET Eire GB-Eire Hongkong Israel Mexico Pacific PST8PDT UCT zone.tabAsia Chile EST GMT HST Jamaica MST Poland right Universal ZuluAtlantic CST6CDT EST5EDT GMT0 Iceland Japan MST7MDT Portugal ROC US$ rm /etc/localtime #删除原有的时区rm：是否删除符号链接 &quot;/etc/localtime&quot;？y$ sudo ln -s /usr/share/zoneinfo/Universal /etc/localtime #设置新的时区$ timedatectl Local time: 三 2018-10-24 15:46:55 UTC Universal time: 三 2018-10-24 15:46:55 UTC RTC time: 三 2018-10-24 15:46:54 Time zone: Universal (UTC, +0000) NTP enabled: n/aNTP synchronized: no RTC in local TZ: no DST active: n/a[root@localhost default]# date2018年 10月 24日 星期三 15:46:58 UTC","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"centos7防火墙","date":"2018-07-09T20:59:00.000Z","path":"2018/07/10/06-centos7防火墙/","text":"centos防火墙1234567891011121314151617181920212223242526272829303132333435363738391、firewalld的基本使用启动： systemctl start firewalld查看状态： systemctl status firewalld 停止： systemctl disable firewalld禁用： systemctl stop firewalld 2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl --failed3.配置firewalld-cmd查看版本： firewall-cmd --version查看帮助： firewall-cmd --help显示状态： firewall-cmd --state查看所有打开的端口： firewall-cmd --zone=public --list-ports更新防火墙规则： firewall-cmd --reload查看区域信息: firewall-cmd --get-active-zones查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0拒绝所有包：firewall-cmd --panic-on取消拒绝状态： firewall-cmd --panic-off查看是否拒绝： firewall-cmd --query-panic 那怎么开启一个端口呢添加firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效）重新载入firewall-cmd --reload查看firewall-cmd --zone= public --query-port=80/tcp删除firewall-cmd --zone= public --remove-port=80/tcp --permanent","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"启动脚本中1,2&是什么","date":"2018-07-07T17:58:00.000Z","path":"2018/07/08/05-启动脚本中1,2&是什么/","text":"启动脚本末尾的2&gt;&amp;1 &amp;的含义脚本中2&gt;&amp;1 &amp;的含义 &emsp;&emsp;我们总是在启动脚本中会发现这样的 “2&gt;&amp;1 &amp;”的奇怪部分，那这部分到底是什么含义呢？ linux标准输入输出流的标示&emsp;&emsp;我们知道设备都有输入输出流，那么linux中是如何去标示它们的呢？1230: 标准stdin输入流1：标准stdout输出流2：标准stderr错误流 举例分析 来看这样一个例子 command >2>&1 & ```12345678910我们对命令进行拆分： ![&amp;](images/how_about_&amp;.png) ```text1：我们执行的命令2：命令执行的打印信息流重定向的设备，**/dev/null**表示一个空设备，即重定向到它后不显示任何信息3：代表标准stderr流4：代表标准stdout输出流，这里的**&amp;**表示不把1当做文件看待，不添加&amp;则会把1当做文件看待5：表示以后台job的形式执行命令6：把stderr流重定向到stdout流","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"重定向符号区别","date":"2018-07-05T16:51:00.000Z","path":"2018/07/06/04-重定向符号区别/","text":"&gt; 和 &gt;&gt; 区别 功能 &emsp;&emsp;都表示重定向到新的设备。 区别 两者的区别主要发生在重定向的设备已经存在时： &gt;会覆盖源文件 &gt;&gt;不会覆盖源文件，而是追加到源文件末尾","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"lrzsz上传下载工具","date":"2018-07-04T13:33:00.000Z","path":"2018/07/04/03-lrzsz上传下载工具/","text":"lrzsz上传下载工具应用场景&emsp;&emsp;我们使用linux时，经常需要与本机完成文件的传输，我们可以使用xftp, 但是还有更简单的命令。 lrzsz的使用 123$ yum install lrzsz$ rz #弹框选择文件上传到linux当前目录 $ sz [file] #从Linux下载文件","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"grep命令","date":"2018-07-04T13:30:00.000Z","path":"2018/07/04/02-grep命令/","text":"grep命令[注：文中的命令参数列表至列出了常用的几个，并不是全部] grep命令 功能 &emsp;&emsp;Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来. 使用方式及参数列表 1234567891011121314151617181920212223242526272829grep [option] pattern file参数列表： -a --text #不要忽略二进制的数据。 -A&lt;显示行数&gt; --after-context=&lt;显示行数&gt; #除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -b --byte-offset #在显示符合样式的那一行之前，标示出该行第一个字符的编号。 -B&lt;显示行数&gt; --before-context=&lt;显示行数&gt; #除了显示符合样式的那一行之外，并显示该行之前的内容。 -c --count #计算符合样式的列数。 -C&lt;显示行数&gt; --context=&lt;显示行数&gt;或-&lt;显示行数&gt; #除了显示符合样式的那一行之外，并显示该行之前后的内容。 -d &lt;动作&gt; --directories=&lt;动作&gt; #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。 -e&lt;范本样式&gt; --regexp=&lt;范本样式&gt; #指定字符串做为查找文件内容的样式。 -E --extended-regexp #将样式为延伸的普通表示法来使用。 -f&lt;规则文件&gt; --file=&lt;规则文件&gt; #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -F --fixed-regexp #将样式视为固定字符串的列表。 -G --basic-regexp #将样式视为普通的表示法来使用。 -h --no-filename #在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H --with-filename #在显示符合样式的那一行之前，表示该行所属的文件名称。 -i --ignore-case #忽略字符大小写的差别。 -l --file-with-matches #列出文件内容符合指定的样式的文件名称。 -L --files-without-match #列出文件内容不符合指定的样式的文件名称。 -n --line-number #在显示符合样式的那一行之前，标示出该行的列数编号。 -q --quiet或--silent #不显示任何信息。 -r --recursive #此参数的效果和指定“-d recurse”参数相同。 -s --no-messages #不显示错误信息。 -v --revert-match #显示不包含匹配文本的所有行。 -V --version #显示版本信息。 -w --word-regexp #只显示全字符合的列。 -x --line-regexp #只显示全列符合的列。 -y #此参数的效果和指定“-i”参数相同 示例 12345678910111213141516171. 进程查找 $ ps -ef|grep redis 2. 查找指定进程个数 $ ps -ef|grep -c svn 3. 从文件中读取关键词进行搜索 $ cat test.txt | grep -f test2.txt 4. 找出已u开头的行内容 $ cat test.txt |grep ^u 5. 去除注释和空格显示 $ cat redis.conf |grep -v &quot;#&quot;|grep -v &quot;^$&quot; &gt; redis-template.conf 6. 显示匹配行后面几行 $ grep -A &apos;options&apos; my.cnf","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]},{"title":"cd命令","date":"2018-07-03T12:11:00.000Z","path":"2018/07/03/01-cd命令/","text":"cd命令1.命令功能 切换当前目录至指定目录下 2.命令格式1cd [dirpath] 3.示例 显示当前目录12$pwd/home/zll 切换目录到当前用户home目录下12345678$cd ~或者$cd ``` &gt; 切换目录到上一次目录下 ```text$cd - 切换到父目录下1$cd ..","tags":[{"name":"Linux","slug":"Linux","permalink":"https://cnkeep.github.io/tags/Linux/"}]}]